%!TEX root = thesis.tex

\chapter{Fazit und Ausblick} % (fold)
\label{cha:fazit_und_ausblick}

\section{Fazit} % (fold)
\label{sec:fazit}

Die Grundlagen des Play-Frameworks wurden erklärt, indem eine einfache statische Web-Anwendung gebaut wurde.
Diese Anwendung wurde mit den Erkenntnissen der Arbeit später um den Real-Time-Aspekt erweitert.
Dies ließ sich mit den Möglichkeiten des Frameworks verhältnismäßig leicht umsetzen.
Der komplizierteste Teil war das Verständnis der Iteratee-Streams und das Wissen um die dazugehörigen Teile, wie Monaden und speziell die \lstinline|Future|-Monade.

Iteratee-Streams bestehen aus den drei Teilen \lstinline|Enumerator|s, \lstinline|Iteratee|s und \lstinline|Enumeratee|s, also den Datenquellen, den Datensenken und den Stream-Transformatoren.
In dieser Arbeit wurde nicht nur gezeigt, wie diese Komponenten angewendet werden, sondern auch, wie eigene \lstinline|Enumerator|s, \lstinline|Iteratee|s und \lstinline|Enumeratee|s erstellt werden können.
Dieser Blick auf die Implementierungsebene ermöglicht aus Sicht des Autors ein wesentlich umfassenderes Verständnis von Plays Iteratee-Streams.

\lstinline|Iteratee|s bieten monadische Operationen an, wodurch das Bearbeiten von gestreamten Elementen auf konsistente Art und Weise erreicht wird.
Die Ergebnisse, die von \lstinline|Iteratee|s berechnet werden, befinden sich immer in der \lstinline|Future|-Monade.
Dies steht im Gegensatz zur ursprünglichen Iteratee-Stream-Implementierung von Oleg Kiselyov, bei der die Monade frei wählbar ist.
Der Grund hierfür wird sein, dass Play das Ziel hat, durch reaktive Programmierung ohne zu Blockieren möglichst effizient zu sein, weshalb sich die \lstinline|Future|-Monade anbietet, auch wenn im Gegenzug Flexibilität eingebüßt wird.
Dies ist aus Sicht des Autors vertretbar und hat für ihn beim Arbeiten mit Play keine Probleme dargestellt.

Dass durch diese Streams aber auch komplexere Prozesse als die erste Beispielanwendung implementiert werden können, wurde mit der Twitter News-Anwendung gezeigt.
Dabei wurden mit \lstinline|Iteratee|s Daten von der Twitter-API empfangen und verarbeitet.
Mit verknüpften \lstinline|Enumeratee|s wurden weitere Tweets heruntergeladen und zwischengespeichert.
Erst nach vollständiger Verarbeitung wurden diese Daten wieder als \lstinline|Enumerator|s der Außenwelt zur Verfügung gestellt und deren Elemente an die verbundenen Clients gesendet.
Insgesamt bilden die von Play zur Verfügung gestellten Werkzeuge aus Sicht des Autors eine solide Grundlage, um Real-Time Web-Anwendungen in einem reaktiven Stil zu entwickeln.

% section fazit (end)

\section{Ausblick} % (fold)
\label{sec:ausblick}

In dieser Arbeit wurde das Hauptaugenmerk auf Play, also die Server-Seite gerichtet und die Client-Seite nur oberflächlich behandelt.
Durch Einsatz eines passenden JavaScript-Frameworks könnte der client-seitige Code wesentlich besser strukturiert werden, wodurch sich Anwendungen mit einer komplexeren Client-Seite besser umsetzen ließen.
Eine weitere Arbeit könnte sich auf die Programmierung der Browser-Seite mit z.~B. AngularJS \cite[vgl.][]{angular_js} oder \mbox{Ember.js} \cite[vgl.][]{ember_js} konzentrieren, die mit einem in Play geschriebenen Server-Backend kommuniziert. % \mbox to prevent line break

Des Weiteren hat sich diese Arbeit fast ausschließlich mit den reaktiven Möglichkeiten des Play-Frameworks beschäftigt, weil diese für die Entwicklung von Real-Time-Web-Anwendungen nötig sind.
Auf viele andere Teile von Play wurde gar nicht oder nur wenig eingegangen, weil dies den Rahmen dieser Arbeit gesprengt hätte.
So wurde beispielsweise das Arbeiten mit Datenbanken komplett ignoriert und für Controller wurde nur die Programmierung einfacher Actions erklärt.
Auch in dieser Richtung gibt es also weitere Möglichkeiten für Forschungen.

Play legt großen Wert auf reaktive Programmierung.
Dieser Trend reduziert sich allerdings nicht alleine auf Play, sondern wird auch von Martin Odersky, dem Begründer von Scala, in einer Online-Vorlesung \cite[vgl.][]{principles_of_reactive_programming} gelehrt.
Die in dieser Arbeit vorgestellten reaktiven Konzepte sind nur ein kleiner Teil der Dinge, die reaktive Programmierung ausmachen.
Jonas Bonér, der Mitarbeiter bei Typesafe ist, ein von Martin Odersky gegründetes Unternehmen, hat unter Mitwirkung anderer Persönlichkeiten der Scala-Community das Reactive Manifesto \cite[vgl.][]{reactive_manifesto} veröffentlicht, in dem die Kernpunkte reaktiver Programmierung beschrieben werden.
Dieses Thema bietet genügend Stoff für eine weiterführende Arbeit darüber.

% section ausblick (end)

% chapter fazit_und_ausblick (end)