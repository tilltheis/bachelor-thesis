%!TEX root = thesis.tex

\chapter{Reaktive Programmierung} % (fold)
\label{cha:reaktive_programmierung}

Reaktive Programmierung ist die Programmierung von reaktiven Systemen.
Ein reaktives System ist ein System, das von seiner Umgebung kontinuierlich Daten empfängt und darauf reagiert.
In nebenläufigen Systemen können gleich mehrere solcher Datenströme unabhängig voneinander existieren \cite[vgl.][S.~1]{reactive_programming}.
Reaktive Prozesse haben die Eigenschaft, schrittweise, immer wenn sie neue Daten empfangen, ein Ergebnis aufzubauen.
Deshalb sind sie bei Berechnungen essentiell, bei denen nicht nur das Endergebnis wichtig ist, sondern auch die Schritte, die dazu geführt haben \cite[vgl.][S.~2]{reactive_programming1}.

In diesem Kapitel werden mit Monaden und speziell der \lstinline|Future|-Monade die Grundbausteine der reaktiven Programmierung mit Play vorgestellt.
Anschließend daran wird Plays Iteratee-Bibliothek vorgestellt, die die zuvor vorgestellten Konzepte nutzt, um eine Stream-Implementierung anzubieten, die zugleich effizient und flexibel ist.

\section{Monaden} % (fold)
\label{sec:monaden}

Monaden sind Container-artige Strukturen, die einige Operationen definieren, um auf den gekapselten Daten zu arbeiten.
Das Konzept der Monaden stammt ursprünglich aus der Mathematik, genauer der Kategorientheorie.
\citealt{monads_program_structure} nutzte Monaden für Beweise über Programmen, worauf \citealt{monads_programming} aufbaute, um Monaden zur Programmierung zu verwenden.
In diesem Abschnitt sollen die mathematischen Hintergründe von Monaden kurz angerissen werden, um diese anschließend im Zusammenhang mit Scala näher zu erläutern.

\subsection{Monaden in der Kategorientheorie} % (fold)
\label{sub:monaden_in_der_kategorientheorie}

Eine Monade in einer Kategorie $C$ ist ein Tripel $T = (T, \eta, \mu)$, wobei $T$ ein Funktor $T: C \to C$ ist und $\eta$ und $\mu$ natürliche Transformationen mit $\eta: Id_C \to T$ und $\mu: T^2 \to T$ sind \citetext{vgl.~\citealp[S.~137]{monads_category_theory}, \citealp[S.~2]{monads_program_structure}}.

Um diese Definition in den Kontext der Programmierung zu übersetzen, soll folgende vereinfachte Erklärung dienen \cite[vgl.][S.~2--3]{monads_programming}:
Eine Kategorie in der Mathematik ist, sehr vereinfacht dargestellt, eine Menge von Objekten und den Operationen auf diesen Objekten \cite[vgl.][S.~7]{monads_category_theory}.
Als die Kategorie $C$ kann die Programmiersprache selber, mitsamt ihrer Typen und den Operationen auf den Werten dieser Typen gesehen werden\cite[vgl.][S.~6--8]{category_theory_and_programming}.
Ein Funktor $T$ ist eine Struktur mit einem einem Operator, der Funktionen $A \to B$ zu Funktionen $T A \to T B$ transformiert.
Natürliche Transformationen können als Funktionen aufgefasst werden.
$\eta$ hebt einen Wert in die Monade und $\mu$ macht aus einer verschachtelten Monade ein nicht-verschachtelte Monade.

Um diese Definition verständlicher zu machen, soll sie in Scala-Code übersetzt werden.
Wird $T$ nach \lstinline|map|, $\eta$ nach \lstinline|unit| und $\mu$ nach \lstinline|join| umbenannt, so ergeben sich die in Listing~\ref{lst:die_monaden_operationen_der_kategorientheorie} gezeigten Typen für eine eine Monade \lstinline|M|.

\begin{lstlisting}[caption=Die Monaden-Operationen der Kategorientheorie, label=lst:die_monaden_operationen_der_kategorientheorie]
def unit[A](a: A): M[A]
def map[A, B](f: A => B): M[A] => M[B]
def join[A](mm: M[M[A]]): M[A]
\end{lstlisting}

Eine Monade ist eine Art Container mit drei assoziierten Operationen.
\lstinline|unit| hebt einen einen Wert in die Monade.
\lstinline|map| transformiert einen Wert innerhalb der Monade.
\lstinline|join| verringert die Tiefe von verschachtelten Monaden um eins.

% subsection monaden_in_der_kategorientheorie (end)

\subsection{Kleisli-Tripel in der Kategorientheorie} % (fold)
\label{sub:kleisli_tripel_in_der_kategorientheorie}

Ein Kleisli-Tripel über einer Kategorie $C$ ist $T = (T, \eta, \_^*)$, wobei $T: Obj(C) \to Obj(C)$, $\eta_A: A \to T A$ und $^*$ ein Operator ist, der Morphismen der Art $f: A \to T B$ nach $f^*: T A \to T B$ umformt \cite[vgl.][S.~2]{monads_program_structure}.

Eine vereinfachte Erklärung für den Kontext der Programmierung ist folgende:
$T$ ist eine Abbildung von einem Objekt der Kategorie $C$ auf ein anderes.
$\eta$ und $^*$ können wieder als Funktionen aufgefasst werden.
$\eta$ hebt einen Wert in den Tripel und $^*$ lässt eine Funktion, die auf Werten arbeitet, die keine Tripel sind, auf Tripeln arbeiten.

Kleisli-Tripel entsprechen Monaden.
Aus jedem Kleisli-Tripel $(T, \eta, \_^*)$ lässt sich eine Monade $(T, \eta, \mu)$ ableiten und umgekehrt, wobei $T(f: A \to B) = (\eta_B \circ f)^*$ und $\mu_A = id^*_{T A}$ \cite[vgl.][S.~2]{monads_program_structure}.

In Scala-Code könnten die Operationen aussehen, wie in Listing~\ref{lst:die_kleisli_tripel_operationen_der_kategorientheorie} gezeigt.
Dabei sind wieder $T$ nach \lstinline|map|, $\eta$ nach \lstinline|unit| und $^*$ nach \lstinline|bind| umbenannt worden.

\begin{lstlisting}[caption=Die Kleisli-Tripel-Operationen der Kategorientheorie, label=lst:die_kleisli_tripel_operationen_der_kategorientheorie]
def unit[A](a: A): M[A]
def bind[A, B](f: A => M[B]): M[A] => M[B]
\end{lstlisting}

% subsection kleisli_tripel_in_der_kategorientheorie (end)

\subsection{Monaden in Scala} % (fold)
\label{sub:monaden_in_der_programmierung}

Wie oben beschrieben, lassen sich die monadischen Semantiken sowohl mit Hilfe von Monaden, als auch mit Hilfe von Kleisli-Tripeln erreichen.
Scala hat Monaden via \lstinline|for|-Comprehensions fest in die Sprache integriert und nutzt dafür sowohl Operationen des Kleisli-Tripels, als auch der klassischen Monade.
In der Scala-Standardbibliothek existiert allerdings kein allgemeines Trait für Monaden.
Um einen Datentyp innerhalb von \lstinline|for|-Comprehensions nutzen zu können, muss dieser die zwei Methoden \lstinline|map| und \lstinline|flatMap| mit den Typen aus Listing~\ref{lst:die_monaden_operationen_in_scala} implementieren.

\begin{lstlisting}[caption=Die Monaden-Operationen in Scala, label=lst:die_monaden_operationen_in_scala]
class M[A] {
  def map[B](f: A => B): M[B] = ???
  def flatMap[B](f: A => M[B]): M[B] = ???
}
\end{lstlisting}

Die \lstinline|map|-Methode entspricht hierbei der \lstinline|map|-Funktion des vorletzten Unterabschnitts und die \lstinline|flatMap|-Methode entspricht der \lstinline|bind|-Funktion des letzten Unterabschnitt.
Für die \lstinline|unit|-Funktion gibt es in Scala kein standardisiertes Pendant.
Stattdessen wird der jeweilige Konstruktor der Monade oder die Konstruktormethode des Companion-Objekts verwendet, sofern diese existieren.
Auch wenn Scalas \lstinline|for|-Comprehensions sie nicht verlangen, so haben die Implementationen der Monaden in der Standardbibliothek i.~d.~R. auch die Methode \lstinline|flatten|, die der als \lstinline|join| vorgestellten Funktion entspricht.
Bevor weiter auf \lstinline|for|-Comprehensions eingegangen wird, sollen einige Beispiele gezeigt werden, um das Konzept zu verdeutlichen.

% subsection monaden_in_der_programmierung (end)

\subsection{Beispiele für Monaden} % (fold)
\label{sub:beispiele_fuer_monaden}

Nachdem bisher nur theoretische Konzepte vorgestellt wurden, sollen an dieser Stelle einige Beispiele für Monaden aufgezeigt werden.
Monaden finden sich in vielen bekannten Datentypen wieder, wie z.~B. \lstinline|Option| oder \lstinline|List|.

\subsubsection{Die Option-Monade} % (fold)
\label{ssub:die_option_monade}

\lstinline|Option| ist ein Datentyp, um optionale Daten darzustellen.
Optionale Daten sind Daten, die vielleicht nicht vorhanden sind und würden in Sprachen, wie z.~B. Java als \lstinline|null| dargestellt werden \cite[vgl.][S.~289]{programming_in_scala}.\todo{Auf algebraischen Datentyp eingehen?}
\lstinline|Some| entspricht dabei \lstinline|unit| und hebt einen Wert in die Monade, wohingegen \lstinline|None| ein Objekt ohne Wert erstellt.
Mit \lstinline|map| und \lstinline|flatMap| kann ein Wert, der mit \lstinline|Some| in die Monade gehoben wurde, verändert werden.

Wenn im Kontext der Altersstatistiken-Anwendung zwei Altersgruppen zusammengezählt werden sollen, könnte dies aussehen, wie in Listing~\ref{lst:die_option_monade}.
Dabei soll für dieses Beispiel ignoriert werden, dass alle Statistiken einen Standardwert von null~(0) für unbekannte Altersangaben zurückgeben.
Dazu werden beide Altersgruppen mit \lstinline|get| ausgelesen, wobei \lstinline|get| das \lstinline|get| von \lstinline|scala.collection.Map| ist und das Ergebnis als \lstinline|Option| zurückliefert.
Anschließend werden beide Ergebnisse mit Hilfe der Monaden-Operationen kombiniert.

\begin{lstlisting}[caption=Die Option-Monade, label=lst:die_option_monade]
val statistics: AgeStatistics = AgeStatistics(20 -> 4, 30 -> 17)

val twentyYearOldCount: Option[Int] = statistics.get(20)
val thirtyYearOldCount: Option[Int] = statistics.get(30)

val twentyAndThirtyYearOldCount: Option[Int] =
  twentyYearOldCount.flatMap(twenties =>
    thirtyYearOldCount.map(thirties => twenties + thirties))
// twentyAndThirtyYearOldCount hat den Wert Some(21)
\end{lstlisting}

% subsubsection die_option_monade (end)

\subsubsection{Die List-Monade} % (fold)
\label{ssub:die_list_monade}

Eine weitere verbreitete Monade ist \lstinline|List|.
Im Gegensatz zur oben vorgestellten \lstinline|Option|-Monade ist \lstinline|List| ein Container, der mehrere Elemente beinhalten kann.
Mit \lstinline|List.apply| lässt sich eine Liste mit einem Element erstellen und entspricht damit der \lstinline|unit|-Funktion.
\lstinline|apply| nimmt zwar beliebig viele Elemente, doch diese Eigenschaft ist hierbei zu vernachlässigen.

Die Methoden \lstinline|map| und \lstinline|flatMap| operieren im Falle von \lstinline|List| i.~d.~R. auf mehreren Elementen.
Nur im Falle, dass die Liste leer ist, haben \lstinline|map| und \lstinline|flatMap| keinen Effekt.
Ist die Liste nicht leer, so wendet \lstinline|map| die übergebene Funktion auf alle Elemente der Liste an.
Bei \lstinline|flatMap| wird die Funktion ebenfalls auf alle Elemente angewendet.
Weil die übergebene Funktion allerdings immer eine neue Liste zurückgibt, werden diese anschließend wieder in eine Liste zusammengefügt.

% subsubsection die_list_monade (end)

% subsection beispiele_fuer_monaden (end)

\subsection{for-Comprehensions} % (fold)
\label{sub:for_comprehensions}

\lstinline|for|-Comprehensions bieten eine alternative Schreibweise für die zuvor vorgestellten Monaden-Operationen.
Durch die Notation mit \lstinline|for|-Comprehensions lassen sich einige längere Ausdrücke, die diese Operationen verwenden, verständlicher ausdrücken, indem die Notation einer imperativen Kontrollstruktur ähnelt.
\lstinline|for|-Comprehensions haben die in Listing~\ref{lst:monaden_operationen_mit_for_comprehension} gezeigte Form.
In diesem Listing, werden, wie schon im Beispiel der \lstinline|Option|-Monade, Werte aus den Monaden \lstinline|twentyYearOldCount| und \lstinline|thirtyYearOldCount| entnommen und anschließend neu zusammengesetzt.

\begin{lstlisting}[caption=Monaden-Operationen mit for-Comprehension, label=lst:monaden_operationen_mit_for_comprehension]
for {
  twenties <- twentyYearOldCount
  thirties <- thirtyYearOldCount
} yield twenties + thirties
\end{lstlisting}

Ausdrücke der Form \lstinline|x <- m| werden Generatoren genannt.
Generatoren werden in \lstinline|map|- und \lstinline|flatMap|-Operationen übersetzt.
Die ersten Generatoren innerhalb einer \lstinline|for|-Comprehension werden zu \lstinline|flatMap|s und der letzte Generator wird zu \lstinline|map| \cite[vgl.][S.~490]{programming_in_scala}.
Wird der Code aus Listing~\ref{lst:monaden_operationen_mit_for_comprehension} nach diesen Regeln umgeformt, so ergibt sich wieder der ursprüngliche Code aus Listing~\ref{lst:die_option_monade}.

% subsection for_comprehensions (end)

\subsection{Gesetze} % (fold)
\label{sub:monadische_gesetze}

Die hier vorgestellten Monaden-Operationen müssen einige Gesetze befolgen, um der mathematischen Definition gerecht zu werden.
Diese Gesetze sind \citealt{monads_program_structure}~(S.~2) und \citealt{real_world_haskell}~(S.~356--257) entnommen.
Sie sollen für die Operationen des Kleisli-Tripels gegeben und anhand von Scala-Code verdeutlicht werden.
Im Scala-Code ist $\eta$ durch die Funktion \lstinline|unit|, die ein Objekt der gewünschten Monade zurückliefert, und $^*$ durch die Methode \lstinline|flatMap| ersetzt worden.
In den folgenden Definition werden die Funktionen $f$ und $g$ verwendet, wobei $f: A \to T B$, $g: B \to T C$ und $T$ das Kleisli-Tripel ist.
Die jeweiligen beiden Seiten von $=$, bzw. \lstinline|=| sind gleich.

\begin{enumerate}
  \item linkes neutrales Element

    $f^* \circ \eta_A = f$\\
    \lstinline|unit(x).flatMap(f) = f(x)|

    \lstinline|unit| ist das linke neutrale Element von \lstinline|flatMap|.
    Anstatt einen Wert mit \lstinline|unit| in eine Monade zu heben, um anschließend darauf \lstinline|flatMap| mit einer Funktion \lstinline|f| aufzurufen, kann direkt \lstinline|f| auf \lstinline|x| angewendet werden.

  \item rechtes neutrales Element

    $\eta^* = id_{T A}$\\
    \lstinline|m.flatMap(unit) = m|

    \lstinline|unit| ist das rechte neutrale Element von \lstinline|flatMap|.
    \lstinline|unit| darf den übergebenen Wert nicht verändern, weshalb es keine Wirkung hat, wenn es auf der rechten Seite von \lstinline|flatMap| steht.

  \item Assoziativität

    $g^* \circ f^* = (g^* \circ f)^*$\\
    \lstinline|m.flatMap(f).flatMap(g) = m.flatMap(x => f(x).flatMap(g))|

    \lstinline|flatMap| ist assoziativ.
    Es macht keinen Unterschied, ob das zweite \lstinline|flatMap| auf dem Ergebnis des ersten aufgerufen wird, oder ob es innerhalb des ersten aufgerufen wird.
    Nur die Reihenfolge der Funktionsaufrufe von \lstinline|f| und \lstinline|g| muss übereinstimmen.
\end{enumerate}

% subsection monadische_gesetze (end)

% section monaden (end)


\section{Futures und Promises} % (fold)
\label{sec:futures_und_promises}

Ein \lstinline|scala.concurrent.Future| ist ein Platzhalter für das Ergebnis einer nebenläufigen Berechnung und hält nach Beendigung dieser Berechnung dessen Ergebnis.
Ein \lstinline|Future| ist an ein \lstinline|scala.concurrent.Promise| gekoppelt, welches einmalig den Wert des \lstinline|Future|s setzen kann.
\lstinline|Future|s sind nur lesbar, wohingegen \lstinline|Promise|s einmalig schreibbar sind.
Dieser Abschnitt behandelt diese beiden Datentypen und orientiert sich dabei an den Quellen \citealt{futures_scala} und \citealt{futures_akka}.

\subsection{Futures} % (fold)
\label{sub:futures}

\lstinline|Future| ist eine Monade, die das Ergebnis einer nebenläufigen Berechnung kapselt.
Ein \lstinline|Future| ein Datentyp, der entweder für ein erfolgreich berechnetes Ergebnis, für einen aufgetretenen Fehler, oder für eine noch andauernde Berechnung steht.
Solange kein Fehler aufgetreten und auch die Berechnung noch nicht vollendet ist, ist auch das \lstinline|Future| noch nicht vollendet und hält kein Ergebnis.
Über den \lstinline|Future|-Datentyp kann in nicht-blockierender Art und Weise auf dem berechneten Ergebnis operiert werden.

\subsubsection{Futures ohne Promise erstellen} % (fold)
\label{ssub:futures_erstellen}

Um ohne \lstinline|Promise| einen \lstinline|Future|-Wert zu erstellen, stellt das \lstinline|Future|-Companion-Objekt mehrere Konstruktormethoden bereit.
\lstinline|Future.successful| erstellt aus einem konkreten Wert einen bereits vollendeten \lstinline|Future|.
\lstinline|Future.failed| erstellt aus einem \lstinline|Throwable| einen \lstinline|Future| im Fehlerzustand.
\lstinline|Future.apply| erstellt aus einer Berechnung (\lstinline|=> A|) einen \lstinline|Future| im erfolgreich vollendeten Zustand, wenn die Berechnung zu einem Ergebnis kommt oder einen \lstinline|Future| im Fehlerzustand, wenn die Berechnung eine \lstinline|Exception| wirft.
Fatale \lstinline|Exceptions| (\lstinline|VirtualMachineError|, \lstinline|NotImplementedError| u.~a., vgl.~\citealt{nonfatal_exceptions}) werden im Thread, in dem \lstinline|Future.apply| aufgerufen wurde allerdings wieder geworfen.
Im Falle von \lstinline|Future.apply| wird die Berechnung im Hintergrund ausgeführt, sodass die Berechnung nicht die aktuellen Thread blockiert.
Wodurch dieses Verhalten realisiert wird, wird in Unterabschnitt~\ref{sub:execution_contexts} beschrieben.

% subsubsection futures_erstellen (end)

\subsubsection{Futures verwenden} % (fold)
\label{ssub:futures_verwenden}

Wie alle Monaden in Scala, haben \lstinline|Future|s die Methoden \lstinline|map| und \lstinline|flatMap| womit auf das jeweils berechnete Ergebnis zugegriffen werden kann.
\lstinline|def map[S](f: T => S): Future[S]| führt die übergebene Funktion aus, sobald die Berechnung des \lstinline|Future|s zu einem Ergebnis gekommen ist.
Führt die Berechnung zu keinem Ergebnis, weil ein Fehler aufgetreten ist, so wird auch die übergebene Funktion nicht ausgeführt.
Mit \lstinline|def flatMap[S](f: T => Future[S]): Future[S]| verhält es sich genauso.
Keine dieser Methoden blockiert den aktuellen Thread, weil die übergebenen Funktionen im Hintergrund ausgeführt werden.

Um mehrere \lstinline|Future|s zu kombinieren, bedeutet zu warten, bis alle \lstinline|Future|s ihre Berechneten Werte halten, erst dann kann mit diesen Werten weitergearbeitet werden.
Listing~\ref{lst:futures_kombinieren} zeigt, wie dies für zwei \lstinline|Future|s umgesetzt werden könnte.
Die Werte \lstinline|f1| und \lstinline|f2| könnten für die nächsten beiden eingehenden Altersangaben der Statistikenanwendung stehen.

\begin{lstlisting}[caption=Futures kombinieren, label=lst:futures_kombinieren]
val f1: Future[Int] = Future(35)
val f2: Future[Int] = Future(40)

val f1f2: Future[(Int, Int)] = for {
  age1 <- f1
  age2 <- f2
} yield (age1, age2)
// f1f2 hat den Wert Future((35, 40))
\end{lstlisting}

Das \lstinline|Future|-Trait und das dazugehörige Companion-Objekt bieten noch weitere Möglichkeiten, mit \lstinline|Futures| zu arbeiten, sie zu kombinieren und v.~a. Fehler zu behandeln.
Dieser Unterabschnitt beschränkt sich allerdings auf die monadischen Operationen auf \lstinline|Futures|.

% subsubsection futures_verwenden (end)

% subsection futures (end)

\subsection{Promises} % (fold)
\label{sub:promises}

\lstinline|Promise|s sind neben \lstinline|Future|s der zweite Teil der \lstinline|Future|s-API.
Mit Hilfe von \lstinline|Promise|s können \lstinline|Future|s einmalig Werte zugewiesen werden, wonach diese nicht mehr verändert werden können.
Um \lstinline|Promise|s zu erstellen können im Companion-Objekt die drei Methoden \lstinline|Promise.success|, \lstinline|Promise.failure| und \lstinline|Promise.apply| verwendet werden.
\lstinline|success| und \lstinline|failure| nehmen einen konkreten Wert, bzw. einen \lstinline|Throwable|-Wert, mit dem das assoziierte \lstinline|Future|-Objekt vollendet wird.
\lstinline|apply| erstellt ein \lstinline|Promise|, dessen \lstinline|Future| noch keinen Wert besitzt.

Um dem \lstinline|Future| eines \lstinline|Promise|s, das mit \lstinline|Promise.apply| erstellt wurde, einen Wert zuzuweisen, können die Methoden \lstinline|success|, bzw. \lstinline|failure| auf dem \lstinline|Promise| aufgerufen werden, die wieder einen konkreten Wert, bzw. ein \lstinline|Throwable|-Objekt als Argument nehmen.
Der Rückgabewert dieser beiden Methoden ist das \lstinline|Promise|-Objekt, auf dem sie aufgerufen wurden.
Wird ein zweites Mal versucht, dem assoziierten \lstinline|Future| einen Wert zuzuweisen, wird eine \lstinline|IllegalStateException| geworfen.
Mit der Methode \lstinline|future| kann auf das assoziierte \lstinline|Future|-Objekt eines \lstinline|Promise|s zugegriffen werden.
Listing~\ref{lst:future_erstellung_mit_einem_promise} zeigt, wie ein Future erstellt wird, das nach 2 Sekunden mit einem \lstinline|Int| erfüllt wird.

\begin{lstlisting}[caption=Future-Erstellung mit einem Promise, label=lst:future_erstellung_mit_einem_promise]
val promise: Promise[Int] = Promise()
val future: Future[Int] = promise.future

future.foreach(x => println(s"Die Zahl ist $x."))
// gibt nach 2 Sekunden "Die Zahl ist 42." aus

Future {
  Thread.sleep(2000)
  promise.success(42)
}
\end{lstlisting}

% subsection promises (end)

\subsection{Execution Contexts} % (fold)
\label{sub:execution_contexts}

Die nebenläufigen Berechnungen, die von \lstinline|Future|s ausgeführt werden, werden innerhalb von \lstinline|scala.concurrent.ExecutionContext|s ausgeführt.
Ein \lstinline|ExecutionContext| ist vergleichbar mit einem Thread-Pool und ist dafür zuständig, dass an ihn delegierte Aufgaben im Hintergrund ausgeführt werden.
Die zuvor vorgestellte Methode \lstinline|Future.apply| nimmt neben der Berechnungsanweisung auch einen impliziten Parameter vom Typ \lstinline|ExecutionContext|.
Dieser \lstinline|ExecutionContext| muss nicht per Hand erstellt werden.
Mittels \lstinline|import scala.concurrent.ExecutionContext.Implicits.global| kann ein vordefinierter \lstinline|ExecutionContext| importiert werden.

% subsection execution_contexts (end)

% section futures_und_promises (end)


\section{Streams} % (fold)
\label{sec:streams}

Streams sind inkrementelle Datenströme, die nicht-blockierendes Lesen erlauben und kombiniert und transformiert werden können.
Sie erlauben inkrementelle und funktionale Datenverarbeitung mit voller Kontrolle über den Ressourcenverbrauch.
Anwendungsbeispiele für Streams sind beispielsweise die Implementierung von Web-Servern oder Datenkompression.
Die in diesem Kapitel vorgestellten Streams sind auch bekannt als Iteratee I/O.
Sie entstanden im Umfeld der Programmiersprache Haskell und wurden von Oleg Kiselyov vorgestellt \cite[vgl.][S.~19]{monad_reader}.
Als Quellen hierfür dienen \citealt{kiselyov2012}, \citealt{iteratee_io}, \citealt{monad_reader} und die Seiten der offiziellen Play-Dokumentation (\citealt{iteratees}, \citealt{enumerators},, \citealt{enumeratees}, \citealt{play_api_documentation}).


\subsection{Design von Streams} % (fold)
\label{sub:design}

Iteratee IO-Streams bestehen aus den vier Komponenten \lstinline|Input|, \lstinline|Iteratee|, \lstinline|Enumerator| und \lstinline|Enumeratee|.
\lstinline|Input|s beinhalten die gestreamten Elemente.
\lstinline|Iteratee|s konsumieren \lstinline|Input|-Elemente und dienen somit als Datensenken.
\lstinline|Enumerator|s generieren \lstinline|Input|-Elemente und dienen somit als Datenquellen.
\lstinline|Enumeratee|s transformieren \lstinline|Iteratee|s und \lstinline|Enumerator|s.
Diese Komponenten und ihr jeweiliger Verwendungszweck werden in den folgenden Unterabschnitten näher vorgestellt.

% subsection design (end)


\subsection{Design von Inputs} % (fold)
\label{sub:design_inputs}

Die von der Datenquelle generierten Elemente werden in \lstinline|Input|s verpackt.
Der Datentyp \lstinline|Input| ist definiert, wie in Listing~\ref{lst:der_input_datentyp} gezeigt \cite[vgl.][Z.~239]{play_iteratee_source_code}.

\begin{lstlisting}[caption=Der Input-Datentyp, label=lst:der_input_datentyp]
sealed trait Input[+E]
object Input {
  case class El[+E](e: E) extends Input[E]
  case object Empty extends Input[Nothing]
  case object EOF extends Input[Nothing]
}
\end{lstlisting}

Der Datentyp ist über den \glslink{kovarianz}{kovarianten} Typ \lstinline|E| der gehaltenen Elemente parametrisiert.
\gls{kovarianz} eines Typs \lstinline|E| ist in Scala am \lstinline|+|-Prefix zu erkennen und bedeutet, dass wenn \lstinline|F| ein spezialisierter Typ von \lstinline|E| ist, \lstinline|Input[F]| auch ein spezialisierter Typ von \lstinline|Input[E]| ist \cite[vgl.][S.~393]{programming_in_scala}.
Dadurch wären beispielsweise sowohl \lstinline|Input[Cat]|, als auch \lstinline|Input[Dog]| Spezialisierungen von \lstinline|Input[Animal]|.
Wäre \lstinline|Input| nicht \glslink{kovarianz}{kovariant} über den Typ der der gehaltenen Elemente, wären \lstinline|Input[Cat]|, \lstinline|Input[Dog]| und \lstinline|Input[Animal]| völlig unterschiedliche Typen.

Des Weiteren ist anzumerken, dass \lstinline|Input| ein \gls{adt} ist.
Ein \gls{adt} ist ein Datentyp mit mehreren, alternativen Konstruktoren, die jeweils eigene Felder besitzen.
Mittels Pattern Matching kann i.~d.~R. von einem Wert eines solchen Datentyps auf den verwendeten Konstruktor geschlossen werden \cite[vgl.][S.~14--15]{algebraic_data_type}.

In Scala werden algebraische Datentypen häufig mit Hilfe von einem Marker-Trait und \lstinline|case|-Klassen und -Objekten implementiert.
Das Marker-Trait ist der \gls{adt} und die \lstinline|case|-Klassen und -Objekte sind die Konstruktoren.
Die Nutzung von \lstinline|case|-Klassen und -Objekten hat den Vorteil, dass diese mittels Pattern Matching zerlegt werden können.
Dadurch, dass das Marker-Trait \lstinline|sealed| ist, wird verhindert, dass von außerhalb der Quellcode-Datei weitere Konstruktoren hinzugefügt werden können \cite[vgl.][]{algebraic_data_type_scala}.
In diesem Fall besitzt der \gls{adt} \lstinline|Input| die Konstruktoren \lstinline|El|, \lstinline|Empty| und \lstinline|EOF|.
Der Konstruktor \lstinline|El| besitzt ein Feld, \lstinline|Empty| und \lstinline|EOF| besitzen keine Felder.

Für den Fall, dass die Datenquelle nicht erschöpft ist, existiert im Companion-Objekt die Unterklasse \lstinline|Input.El| mit dazugehöriger Konstruktormethode.
Diese Implementierung hält genau ein Element aus der Datenquelle.
Über die Entsprechung zu \lstinline|Input.Empty| in Kiselyovs Implementierung schreibt er "`[it] signifies a stream with no immediately available data but which is still continuing"' \cite[vgl.][]{iteratee_io}.
Außerdem findet es im Kontext von \lstinline|Iteratee|s Verwendung, um zu signalisieren, dass kein Teil der Eingabe übriggebliebenen ist.
Wenn die Datenquelle erschöpft ist, wird dies mit dem Objekt \lstinline|Input.EOF| mitgeteilt.

Sowohl \lstinline|Input.Empty|, als auch \lstinline|Input.EOF| sind vom Typ \lstinline[mathescape]|$\text{\gls{nothing}}$|.
\lstinline[mathescape]|$\text{\gls{nothing}}$| ist ein besonderer Typ in Scala, ein so genannter Bottom-Typ.
Das bedeutet, dass er ganz unten in der Klassenhierarchie steht und eine Spezialisierung jedes anderen Typs ist.
Es gibt keine Instanz vom Typ \lstinline[mathescape]|$\text{\gls{nothing}}$|, aufgrund seiner Position in der Klassenhierarchie kann er jedoch jeden anderen Typ annehmen \cite[vgl.][S.~216]{programming_in_scala}.
Weil der Typparameter des \lstinline|Input|-Datentyps \glslink{kovarianz}{kovariant} ist, lassen sich \lstinline|Input.Empty| und \lstinline|Input.EOF| mit jedem anderen \lstinline|Input| kombinieren.

Ein Wert vom Typ \lstinline|Input| hat also drei mögliche Zustände:
\begin{enumerate}
  \item Es gibt ein neues Element (\lstinline|Input.El|).
  \item Es gibt noch kein neues Element, doch die Datenquelle ist noch aktiv (\lstinline|Input.Empty|)
  \item Die Datenquelle ist erschöpft (\lstinline|Input.EOF|).
\end{enumerate}

% subsection design_inputs (end)


\subsection{Design von Iteratees} % (fold)
\label{sub:design_iteratees}

Die von der Datenquelle in \lstinline|Input|s verpackten Elemente werden von \lstinline|Iteratee|s konsumiert, um daraus ein Ergebnis aufzubauen.
\lstinline|Iteratee|s kapseln ihren Zustand \lstinline|Step|, der den Verarbeitungszustand widerspiegelt.
Der Typ des \lstinline|Step|-Zustands ist wie in Listing~\ref{lst:der_step_datentyp} gezeigt \cite[vgl.][Z.~271]{play_iteratee_source_code}.
\begin{lstlisting}[caption=Der Step-Datentyp, label=lst:der_step_datentyp]
sealed trait Step[E, +A]
object Step {
  case class Done[+A, E](a: A, remaining: Input[E])
    extends Step[E, A]
  case class Cont[E, +A](k: Input[E] => Iteratee[E, A])
    extends Step[E, A]
  case class Error[E](msg: String, input: Input[E])
    extends Step[E, Nothing]
}
\end{lstlisting}

Der \gls{adt} ist über die zwei Typen \lstinline|E| und \lstinline|A| parametrisiert.
\lstinline|E| ist der Typ der zu konsumierenden Elemente.
\lstinline|A| ist der Typ des zu berechnenden Ergebnisses.
\lstinline|A| ist \glslink{kovarianz}{kovariant}, sodass auch Spezialisierungen von \lstinline|A| als Werte verwendet werden können.
Die \gls{kovarianz} über den Typ \lstinline|A| ermöglicht es auch hier wieder \lstinline[mathescape]|$\text{\gls{nothing}}$| in den Konstruktoren zu verwenden, wie im vorigen Unterabschnitt beschrieben.

Ein \lstinline|Iteratee|, der mit seiner Berechnung fertig ist, ist im Zustand \lstinline|Step.Done|.
Ein solcher \lstinline|Iteratee| hält sein berechnetes Ergebnis und den Teil der letzten Eingabe, der nicht mehr verarbeitet wurde.
Ein \lstinline|Iteratee| in diesem Zustand nimmt keine weiteren Elemente an.
Häufig ist der Eingaberest \lstinline|Input.Empty|, weil die gesamte Eingabe konsumiert wurde.
Ein Beispiel für einen nicht leeren Eingaberest ist, wenn ein \lstinline|Iteratee| zeilenweise Dateiinhalte empfängt und darin nach einem Wort sucht.
Wenn das gesuchte Wort gefunden wurde, wird als Restwert der bisher nicht angesehene Rest der Zeile verwendet.

Ein \lstinline|Iteratee|, der noch kein Endergebnis berechnet hat, ist im Zustand \lstinline|Step.Cont|.
Das Argument von \lstinline|Step.Cont| ist die Schritt-Funktion \lstinline[breaklines=true]|Input[E] => Iteratee[E, A]|.
Die Eingabe der Schritt-Funktion ist ein \lstinline|Input| mit einem neuen zu verarbeitenden Element.
Die Ausgabe ist ein neuer \lstinline|Iteratee|, der den neuen Berechnungsstand nach dem Verarbeiten des Eingabeelements hält.
Diese Funktion wird als Continuation bezeichnet.
Eine Delimited Continuation repräsentiert den Rest einer Berechnung bis zu einem bestimmten Punkt \cite[vgl.][S.~1]{continuations}.
In diesem Fall berechnet die Continuation immer die Verarbeitung genau eines weiteren Elements.

Falls bei der Verarbeitung eines Elements ein Fehler auftritt, wird dies durch den Zustand \lstinline|Step.Error| signalisiert.
Ein solcher Fehler wird durch eine Fehlermeldung und durch das verursachende Eingabeelement dargestellt.
Beispielsweise kann ein \lstinline|Iteratee| nach dem Empfang eines \lstinline|Input.EOF|-Elements signalisieren, dass es noch mehr Daten benötigt.
%In diesem Fall kann das System versuchen doch noch mehr Daten zu finden, sodass der \lstinline|Iteratee| erfolgreich zu einem Ergebnis kommen kann.

Ein \lstinline|Iteratee| hat also einen Verarbeitungszustand vom Typ \lstinline|Step| mit drei möglichen Zuständen:
\begin{enumerate}
  \item Es wurde erfolgreich ein Ergebnis berechnet (\lstinline|Step.Done|).
  \item Es werden weitere Daten zur Berechnung benötigt (\lstinline|Step.Cont|).
  \item Es ist ein Fehler aufgetreten (\lstinline|Step.Error|).
\end{enumerate}

Außerdem ist anzumerken, dass der \lstinline|Iteratee|-Typ eine Monade ist.
Dadurch ist es möglich, einen beliebigen Wert in die Monade zu heben, die dann im \lstinline|Step.Done|-Zustand ist.
Auch kann ein erfolgreich berechneter Wert innerhalb der Monade transformiert werden.
Mehr dazu in Unterabschnitt~\ref{ssub:iteratees_sind_monaden} (\nameref{ssub:iteratees_sind_monaden}).

% subsection design_iteratees (end)


\subsection{Design von Enumerators} % (fold)
\label{sub:design_enumerators}

Ein \lstinline|Enumerator| ist die Datenquelle, die ihre Daten, in \lstinline|Input|s verpackt, bereitstellt.
Der Datentyp \lstinline|Enumerator| ist definiert, wie in Listing~\ref{lst:der_enumerator_datentyp} vereinfacht dargestellt \cite[vgl.][]{play_enumerator_source_code}.
\begin{lstlisting}[caption=Der Enumerator-Datentyp, label=lst:der_enumerator_datentyp]
trait Enumerator[E] {
  def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]]
}
\end{lstlisting}

Ein \lstinline|Enumerator| ist eine Funktion von \lstinline|Iteratee| nach \lstinline|Iteratee| und ist über die Typen des übergebenen \lstinline|Iteratee|s parametrisiert.
Der Eingabewert ist der \lstinline|Iteratee|, an den die generierten Elemente gesendet werden.
Der Rückgabewert ist der übergebene \lstinline|Iteratee| nach Fertigstellung oder Abbruch seiner Berechnung.
Der zurückgegebene \lstinline|Iteratee| befindet sich in der \lstinline|Future|-Monade.

Bei der Anwendung dieser Funktion werden dem \lstinline|Iteratee| so lange Daten übergeben, bis die Datenquelle erschöpft ist oder bis der \lstinline|Iteratee| keine Daten mehr annimmt.
Die Herkunft der Daten, die der \lstinline|Enumerator| an den \lstinline|Iteratee| sendet, ist beliebig.
Weil der Rückgabetyp sich in der \lstinline|Future|-Monade befindet, können auch zeitintensive Berechnungen durchgeführt werden, ohne den Programmfluss zu unterbrechen.
Dadurch ist es beispielsweise möglich, die Daten aus Dateien oder dem Netzwerk zu empfangen ohne zu blockieren.

% subsection design_enumerators (end)


\subsection{Design von Enumeratees} % (fold)
\label{sub:design_enumeratees}

Ein \lstinline|Enumeratee| ist ein Stream-Transformator, der \lstinline|Iteratee|s eines bestimmten Element-Typs zu \lstinline|Iteratee|s eines anderen Element-Typs konvertiert.
Der Datentyp \lstinline|Enumeratee| ist definiert, wie in Listing~\ref{lst:der_enumeratee_datentyp} vereinfacht dargestellt \cite[vgl.][]{play_enumeratee_source_code}.
\begin{lstlisting}[caption=Der Enumeratee-Datentyp, label=lst:der_enumeratee_datentyp]
trait Enumeratee[From, To] {
  def apply[A](inner: Iteratee[To, A]):
    Iteratee[From, Iteratee[To, A]]
}
\end{lstlisting}

Ein \lstinline|Enumeratee| ist eine Funktion von \lstinline|Iteratee| nach \lstinline|Iteratee|.
Der Eingabewert ist der zu transformierende \lstinline|Iteratee| vom inneren Element-Typ \lstinline|To|.
Der Ausgabewert ist ein \lstinline|Iteratee| vom äußeren Element-Typ \lstinline|From|.
Der neue \lstinline|Iteratee| nimmt Elemente vom Typ \lstinline|From| an und transformiert sie nach \lstinline|To|.
Diese transformierten Werte werden dann an den ursprünglichen \lstinline|Iteratee| weitergegeben.

Elemente vom Typ \lstinline|From| heißen äußere Elemente, weil sie vom resultierenden \lstinline|Iteratee| zuerst empfangen werden.
Elemente vom Typ \lstinline|To| heißen innere Elemente, weil sie zum \lstinline|Iteratee| gehören, das sich im Rückgabetyp des resultierenden \lstinline|Iteratee|s befindet.
Die Elemente des äußeren \lstinline|Iteratees| werden nach der Transformation an den inneren \lstinline|Iteratee| weitergereicht.

Die Transformation muss dabei aber nicht ein Element nach genau einem anderen Element abbilden.
Ein äußeres Element \lstinline|From| kann zu einem, keinem oder auch mehreren inneren Elementen \lstinline|To| abgebildet werden.
Genauso ist es möglich, dass mehrere äußere Elemente zu einem inneren Element zusammengefasst werden.

\begin{sloppypar} % larger word spacing so that \lstinline will not go out of line margin
Ein \lstinline|Enumeratee| kann auch als \lstinline|Enumerator| betrachtet werden.
Dies kommt daher, dass \lstinline|Iteratee|s Monaden sind.
Ein \lstinline|Enumeratee| ist ein \lstinline|Enumerator|, dessen Ergebnis nicht in der \lstinline|Future|-Monade, sondern in der \lstinline|Iteratee|-Monade liegt.
Jeder \lstinline|Enumeratee| ist auch ein \lstinline|Iteratee|, wenn man seinen Rückgabewert betrachtet, der vom Typ \lstinline|Iteratee| ist.
Ein \lstinline|Enumeratee| ist also sowohl in der Rolle eines \lstinline|Iteratee|s, als auch in der Rolle eines \lstinline|Enumerator|s.
Er ist ein \lstinline|Iteratee| des äußeren Typs \lstinline|From| und ein \lstinline|Enumerator| des inneren Typs \lstinline|To|, weil er Elemente des äußeren Typs konsumiert und Elemente des inneren Typs generiert.
\end{sloppypar}

% subsection design_enumeratees (end)


\subsection{Design von Komposition} % (fold)
\label{sub:komposition}

Bei der Komposition werden zwei oder mehr \lstinline|Iteratee|s oder \lstinline|Enumerator|s zu einem neuen \lstinline|Iteratee| oder \lstinline|Enumerator| kombiniert.
Es gibt hierbei zwei prinzipielle Arten der Komposition.
Diese Arten sind die sequentielle und die parallele Komposition.

\subsubsection{Komposition von Iteratees} % (fold)
\label{ssub:komposition_von_iteratees}

Sequenzielle Komposition zweier \lstinline|Iteratee|s funktioniert nach folgendem Prinzip:
Zuerst wird der erste \lstinline|Iteratee| angewendet, bis er keine Elemente mehr annimmt oder die Datenquelle erschöpft ist.
Dann wird der zweite \lstinline|Iteratee| auf die noch übrigen Elemente der Datenquelle angewendet, bis auch dieser \lstinline|Iteratee| keine Elemente mehr annimmt, oder die Datenquelle erschöpft ist.
Anschließend werden die Ergebnisse beider \lstinline|Iteratee|s kombiniert, z.~B. als Paar. % Iteratee#map/flatMap

Bei der parallelen Komposition werden die Elemente der Datenquelle an beide \lstinline|Iteratee|s weitergegeben.
Dies geschieht im Gegensatz zur sequentiellen Komposition allerdings ohne, dass zuerst ein \lstinline|Iteratee| vollständig beendet sein muss.
Es ist möglich \lstinline|Iteratee|s so zu kombinieren, dass der resultierende \lstinline|Iteratee| eine Datenquelle auf mehrere Datensenken abbildet.
Die Datensenken sind hierbei die kombinierten \lstinline|Iteratee|s.
Beispielsweise können die Elemente der Datenquelle immer an beide \lstinline|Iteratee|s weitergegeben werden, um die Ergebnisse beider \lstinline|Iteratee|s anschließend als Paar zu zusammenzufassen. % Enumeratee.zip/zipWith

Eine weitere Art der parallelen Komposition ist es, mehrere Datenquellen auf eine Datensenke abzubilden.
Es wird hierbei ein \lstinline|Iteratee| erstellt, der von mehreren Datenquellen liest und daraus ein Ergebnis berechnet.
Dieser \lstinline|Iteratee| ist ein verschachtelter \lstinline|Iteratee|, d.~h. das Ergebnis des äußeren \lstinline|Iteratee|s ist der innere \lstinline|Iteratee|, der schließlich das zusammengesetzte Ergebnis zurückgibt (mehr dazu in Unterabschnitt~\ref{ssub:anwendung_parallele_komposition_von_iteratees_mehrere_quellen}).
In Kiselyovs Implementierung ist es möglich, in beliebiger Reihenfolge aus den unterschiedlichen Datenquellen zu lesen.
Nach dem Kenntnisstand des Autors ist dies in Plays Implementierung nicht möglich, weil diese nicht auf einer so hohen Abstraktionsebene arbeitet, wie Kiselyovs.
Der Grund hierfür könnte zum einen sein, dass durch die Einführung einer weiteren Abstraktionsschicht das Verständnis der Iteratee-Implementierung erschwert würde.
Zum anderen könnte es sein, dass dieses Feature im Kontext von Web-Anwendungen zu wenig Verwendung findet und der Implementierungsaufwand deshalb nicht gerechtfertigt ist.

% subsubsection komposition_von_iteratees (end)

\subsubsection{Komposition von Enumerators} % (fold)
\label{ssub:komposition_von_enumerators}

Die sequentielle Komposition zweier \lstinline|Enumerator|s erfolgt ähnlich, wie die sequentielle Kompositionen von \lstinline|Iteratee|s.
Der resultierende \lstinline|Enumerator| generiert erst alle Elemente des ersten \lstinline|Enumerator|s und dann alle Elemente des zweiten \lstinline|Enumerator|s.
Die sequentielle Komposition von \lstinline|Enumerator|s entspricht also der Verkettung ihrer Ausgaben. %Enumerator.andThen

Bei der parallelen Komposition von \lstinline|Enumerator|s werden die Elemente der \lstinline|Enumerator|s nicht nacheinander, sondern durcheinander generiert.
Es muss also nicht erst ein \lstinline|Enumerator| erschöpft sein, bevor Daten generiert werden, die aus einem anderen \lstinline|Enumerator| entstammen.
Eine Möglichkeit ist, dass die Reihenfolge der Elemente dadurch bestimmt wird, welcher \lstinline|Enumerator| zuerst ein neues Element zur Verfügung stellt. % Enumerator.interleave

% subsubsection komposition_von_enumerators (end)

% subsection komposition (end)


\subsection{Anwendung von Streams} % (fold)
\label{sub:anwendung}

In den vorigen Unterabschnitten zum Design der \lstinline|Iteratee|-Streams wurden die Grundkomponenten des Moduls vorgestellt.
In den folgenden Unterabschnitt soll ihr Einsatz mit Hilfe von konkreten Code-Beispielen gezeigt werden.
Es werden häufig mehrere Möglichkeiten für die Verwendung der einzelnen Komponenten erläutert, um die unterschiedlichen Abstraktionsschichten zu verdeutlichen.
Die Codebeispiele stammen, sofern nicht anders vermerkt, vom Autor.

% subsection anwendung (end)


\subsection{Anwendung von Iteratees} % (fold)
\label{sub:iteratees}

Plays \lstinline|Iteratee|s kapseln ihren \lstinline|Step|-Zustand.
Die elementare Methode dieses Traits ist \lstinline|fold|.
Die Signatur dazu ist in Listing~\ref{lst:fold_signatur} zu lesen \cite[vgl.][Z.~400]{play_iteratee_source_code}.
\begin{lstlisting}[caption=Die Signatur von fold, label=lst:fold_signatur]
def fold[B](folder: Step[E, A] => Future[B])
  (implicit ec: ExecutionContext): Future[B]
\end{lstlisting}

Mit Hilfe von \lstinline|fold| lässt sich der Zustand des \lstinline|Iteratee|s transformieren.
Deshalb sind sehr viele Methoden des \lstinline|Iteratee|-Traits auf Basis von \lstinline|fold| definiert.
Durch Übergabe eines \lstinline|Step|-Werts an die \lstinline|folder|-Funktion bestimmt die konkrete \lstinline|Iteratee|-Implementierung, wie mit übergebenen Elementen umzugehen ist und ob überhaupt weitere Elemente akzeptiert werden.
Nur durch die im \lstinline|Step|-Wert befindliche Eingabeverarbeitung kann ein \lstinline|Iteratee| neue Elemente empfangen.
Dadurch wird nach und nach der zu berechnende Wert aufgebaut.
Der implizite Parameter \lstinline|ec| definiert den \lstinline|ExecutionContext|, in dem die internen \lstinline|Future|-Berechnungen ausgeführt werden sollen.
\lstinline|ExecutionContext|s wurden in Unterabschnitt~\ref{sub:execution_contexts} im Kontext von \nameref{sec:futures_und_promises} behandelt.

\subsubsection{Iteratees erstellen} % (fold)
\label{ssub:iteratees_erstellen}

Es gibt drei Möglichkeiten, einen neuen \lstinline|Iteratee| zu erstellen.
\begin{enumerate}
  \item Durch Erstellung einer neuen Klasse, die das \lstinline|Iteratee|-Trait implementiert.
  \item Durch Benutzung einer Konstruktormethode analog zu den \lstinline|Step|-Zuständen (\lstinline|Done|, \lstinline|Cont| und \lstinline|Error|).
  \item Durch Benutzung einer Konstruktormethode des Companion-Objekts (\lstinline|fold|, \lstinline|foreach|, u.~a.).
\end{enumerate}

Zu Demonstrationszwecken soll im Folgenden ein \lstinline|Iteratee| erstellt werden, der alle empfangenen Elemente aufsummiert.
Es wird dabei nach jeder der drei möglichen Varianten implementiert.

\paragraph{Erstellung durch Vererbung} % (fold)
\label{par:erstellung_durch_vererbung}\mbox{} % force new line

Die erste Variante ist, von \lstinline|Iteratee| zu erben und die \lstinline|fold|-Methode zu implementieren.
Dies erfordert viel Schreibarbeit, weil nur die sehr generische \lstinline|fold|-Methode verwendet werden kann.
In Listing~\ref{lst:iteratee_durch_vererbung} ist die Implementierung eines Aufsummierungs-\lstinline|Iteratee|s zu sehen, der verwendet werden könnte, um das Gesamtalter der Altersstatistik aus Kap.~\ref{cha:grundlagen} zu berechnen.

\begin{lstlisting}[caption=Erstellung eines Iteratees durch Vererbung, label=lst:iteratee_durch_vererbung]
case class SumIteratee(sum: Int = 0) extends Iteratee[Int, Int] {
  def fold[B](folder: Step[Int, Int] => Future[B])
      (implicit ec: ExecutionContext): Future[B] = {
    folder(Step.Cont {
      case Input.El(i) => SumIteratee(sum + i)
      case Input.Empty => this
      case Input.EOF   => new Iteratee[Int, Int] {
        def fold[B](folder: Step[Int, Int] => Future[B])
            (implicit ec: ExecutionContext) = {
          folder(Step.Done(sum, Input.EOF))
        }
      }
    })
  }
}

val sumIterateeFromInheritance: Iteratee[Int, Int] = SumIteratee()
\end{lstlisting}

Der \lstinline|folder|-Funktion muss der aktuelle \lstinline|Step|-Zustand übergeben werden.
Diese Funktion soll den \lstinline|Iteratee| dann mit Elementen versorgen.
Anschließend soll der \lstinline|folder| dann aus dem finalen Zustand ein Ergebnis berechnen.
Solange noch weitere Elemente kommen können, also solange kein \lstinline|Input.EOF|-Element empfangen wurde, geht der \lstinline|Iteratee| in einen neuen \lstinline|Cont|-Zustand über.
Bei diesem Zustandsübergang wird auch die interne Berechnung fortgesetzt.
Es wird also in einen \lstinline|Cont|-Zustand übergegangen, der die aktualisierte Summe hält.
Wenn ein leeres Element (\lstinline|Input.Empty|) verarbeitet werden soll, wird der \lstinline|Iteratee| unverändert zurückgegeben, weil sich an der Gesamtsumme nichts geändert hat.
Sobald keine weiteren Elemente mehr kommen können, wird die Berechnung beendet und ein \lstinline|Iteratee| an den \lstinline|folder| übergeben, der sich immer im \lstinline|Done|-Zustand befindet.
Mit dem \lstinline|ExecutionContext| muss nicht direkt gearbeitet werden, es muss nur dafür gesorgt werden, dass ein passender implizieter Wert erstellt oder importiert wurde (z.~B. mittels \lstinline|import scala.concurrent.ExecutionContext.Implicits.global|).

% paragraph erstellung_durch_vererbung (end)

\paragraph{Erstellung durch Konstruktormethode} % (fold)
\label{par:erstellung_durch_konstruktormethode}\mbox{} % force new line

Die zweite Möglichkeit, einen \lstinline|Iteratee| zu erstellen, ist mit Hilfe einer der Konstruktormethoden.
Es gibt die Konstruktormethoden \lstinline|Done|, \lstinline|Cont| und \lstinline|Error|, die jeweils einen \lstinline|Iteratee| im gleichnamigen \lstinline|Step|-Zustand erstellen.
Die Methoden befinden sich direkt im \lstinline|play.api.libs.iteratee|-Paket und sind eigentlich einfache Objekte mit einer \lstinline|apply|-Methode, können aber wie Methoden verwendet werden.
Jede diese Methoden nimmt auch die gleichen Argumente, wie ihr Pendant.
Der Code, der einen Aufsummierungs-\lstinline|Iteratee| mit Hilfe dieser Methoden erstellt, ist in Listing~\ref{lst:iteratee_durch_konstruktormethode} zu sehen.

\begin{lstlisting}[caption=Erstellung eines Iteratees durch eine Konstruktormethode, label=lst:iteratee_durch_konstruktormethode]
def sumIteratee(sum: Int = 0): Iteratee[Int, Int] = Cont {
  case Input.El(i) => sumIteratee(sum + i)
  case Input.Empty => sumIteratee(sum)
  case Input.EOF   => Done(sum, Input.EOF)
}

val sumIterateeFromConstructor: Iteratee[Int, Int] = sumIteratee()
\end{lstlisting}

Der Code ist dem in \nameref{lst:iteratee_durch_vererbung} vorgestellten Code sehr ähnlich.
Im Gegensatz dazu muss hier jedoch nicht mehr explizit von \lstinline|Iteratee| geerbt und die \lstinline|fold|-Methode implementiert werden.
Dies macht den Code schon wesentlich kürzer und einfacher.
Der Code ist auf die elementaren Aufgaben reduziert und es ist nun klar zu erkennen, was bei welcher Art von \lstinline|Input| geschieht.

% paragraph erstellung_durch_konstruktormethode (end)

\paragraph{Erstellung durch Konstruktormethode im Companion-Objekt} % (fold)
\label{par:erstellung_durch_konstruktormethode_im_companion_objekt}\mbox{} % force new line

Die dritte und letzte Möglichkeit nutzt eine problemspezifische Konstruktormethode im Companion-Objekt.
Das Aufsummieren einer Menge von Zahlen lässt sich sehr einfach mit Hilfe eines Folds implementieren.
Das \lstinline|Iteratee|-Companion-Objekt beinhaltet u.~a. die \lstinline|fold|-Konstruktormethode, die für solche Operationen gedacht ist.
Durch Einsatz dieser Methode wird die Lösung, wie in Listing~\ref{lst:iteratee_durch_hilfsmethode} zu erkennen, zum Einzeiler.
Es muss nicht mehr zwischen unterschliedlichen \lstinline|Input|-Arten unterschieden werden, sondern es muss sich nur noch um tatsächliche Eingabeelemente gekümmert werden.

\begin{lstlisting}[caption=Erstellung eines Iteratees durch Konstruktormethode im Companion-Objekt, label=lst:iteratee_durch_hilfsmethode]
val sumIterateeFromHelper: Iteratee[Int, Int] =
  Iteratee.fold(0)(_ + _)
\end{lstlisting}

Eine weitere hilfreiche Konstruktormethode ist \lstinline|getChunks|.
Diese Methode gibt einen \lstinline|Iteratee| zurück, der alle empfangenen Elemente in einer Liste sammelt.
Der Typ dieses \lstinline|Iteratee|s ist entsprechend \lstinline|Iteratee[E, List[E]]|.
Dieser \lstinline|Iteratee| wird im Folgenden zu Veranschaulichungszwecken an einigen Stellen dieser Arbeit verwendet.

% paragraph erstellung_durch_konstruktormethode_im_companion_objekt (end)

% subsubsection iteratees_erstellen (end)

\subsubsection{Iteratees ausführen} % (fold)
\label{ssub:iteratees_ausfuehren}

Um die \lstinline|Iteratee|s mit Daten zu versorgen, existiert, wie in \nameref{ssub:iteratees_erstellen} beschrieben, die Methode \lstinline|fold|.
\lstinline|fold| nimmt als Argument eine Funktion \lstinline|folder| vom Typ \lstinline[breaklines=true]|Step[E, A] => Future[B]|.
Diese Funktion übergibt ein Element an den \lstinline|Iteratee| und muss daraufhin den Zustand des neuen \lstinline|Iteratee|s überprüfen, ob weitere Elemente akzeptiert werden.
Erst nach dieser Analyse kann entschieden werden, ob ein weiteres Element übergeben wird oder nicht.
In Listing~\ref{lst:iterateeausfuehrung_durch_folder} wird gezeigt, wie dem zuvor erstellten \lstinline|Iteratee| zur Berechnung des Gesamtalters, die einzelnen Altersangaben in Form von \lstinline|Int|s zugeführt werden.

\begin{lstlisting}[caption=Ausführung eines Iteratees durch folder-Funktion, label=lst:iterateeausfuehrung_durch_folder]
def folder(xs: Int*)(step: Step[Int, Int]): Future[Int] = {
  def folder_(xs: List[Int])(step: Step[Int, Int]): Future[Int] =
    xs match {
      case Nil => step match {
        case Step.Cont(k) => k(Input.EOF).fold {
          case Step.Done(sum, Input.EOF) => Future(sum)
          case _ => Future.failed(new Exception("invalid state"))
        }
        case _ => Future.failed(new Exception("invalid state"))
      }
      case x :: xs => step match {
        case Step.Cont(k) => k(Input.El(x)).fold(folder_(xs))
        case _ => Future.failed(new Exception("invalid state"))
      }
    }

  folder_(xs.toList)(step)
}

val sumResult: Future[Int] =
  sumIterateeFromHelper.fold(folder(22, 25, 54))
// sumResult hat den Wert Future(101)
\end{lstlisting}

Das Übergeben von Daten mittels der \lstinline|fold|-Methode ist, wie in Listing~\ref{lst:iterateeausfuehrung_durch_folder} zu erkennen, recht aufwändig.
Dies kommt daher, dass zwei Zustände geprüft werden müssen.
Zum Einen muss der Zustand der Eingabemenge geprüft werden, ob noch Elemente existieren, die an den \lstinline|Iteratee| übergeben werden sollen.
Zum Anderen muss sichergestellt werden, dass der \lstinline|Iteratee| sich korrekt verhält.
Ein \lstinline|Iteratee| verhält sich korrekt, wenn er nach dem Empfang von \lstinline|Input.EOF| keine weiteren Element annimmt, also in einen Endzustand übergeht.
Nur wenn all diese Voraussetzungen erfüllt wurden, kann am Ende das Ergebnis dem \lstinline|Iteratee| im \lstinline|Step.Done|-Zustand entnommen werden.
Durch Verwendung von \lstinline|Enumerator|s wird dies allerdings wesentlich einfacher.

% subsubsection iteratees_ausfuehren (end)

\subsubsection{Iteratees sind Monaden} % (fold)
\label{ssub:iteratees_sind_monaden}

\lstinline|Iteratee|s sind Monaden und haben deshalb die in Scala für Monaden üblichen Methoden \lstinline|map| und \lstinline|flatMap|.
Um einen Wert in die Monade zu heben wird der Konstruktor \lstinline|play.api.libs.iteratee.Done| verwendet, der dadurch erstellte \lstinline|Iteratee| ist anschließend im \lstinline|Step.Done|-Zustand.
Mit \lstinline|map| kann ein erfolgreich berechneter Wert, also ein Wert innerhalb eines \lstinline|Iteratee|s im \lstinline|Step.Done|-Zustand verändert werden.
Mit \lstinline|flatMap| kann ebenfalls ein erfolgreich berechneter Wert verändert werden, doch mit dem Unterschied, dass die an \lstinline|flatMap| übergebene Funktion einen neuen \lstinline|Iteratee| zurückgibt, der aber nicht unbedingt auch im \lstinline|Step.Done|-Zustand sein muss.

% subsubsection iteratees_sind_monaden (end)

% subsection iteratees (end)

\subsection{Anwendung von Enumerators} % (fold)
\label{sub:enumerators}

Mit Hilfe von \lstinline|Enumerator|s können auf einfache Weise Daten an \lstinline|Iteratee|s übergeben werden.
In diesem Unterabschnitt werden Anwendung und Funktionsweise von \lstinline|Enumerator|s gezeigt.
Es wird erklärt, auf welche Arten \lstinline|Enumerator|s erstellt werden können, und wie sie genutzt werden können, um Daten an \lstinline|Iteratee|s zu übergeben.

\subsubsection{Enumerators erstellen} % (fold)
\label{ssub:enumerators_erstellen}

Es gibt drei unterschiedliche Techniken, einen \lstinline|Enumerator| zu erstellen.
\begin{enumerate}
  \item Durch Erstellung einer neuen Klasse, die das \lstinline|Enumerator|-Trait implementiert.
  \item Durch Benutzung einer Konstruktormethode im Companion-Objekt (\lstinline|apply|, \lstinline|generateM|, u.~a.).
  \item Durch Benutzung einer Konstruktormethode im \lstinline|play.api.libs.iteratee.Concurrent|-Objekt (\lstinline|broadcast|, \lstinline|unicast|, u.~a.).
\end{enumerate}

Das o.~g. \lstinline|Concurrent|-Objekt stellt u.~a. Konstruktoren für imperativ steuerbare \lstinline|Enumerator|s bereit.
Im Folgenden werden alle Herangehensweisen vorgestellt, um Zahlen für den im vorigen Unterabschnitt vorgestellten Summierungs-\lstinline|Iteratee| zu generieren.

\paragraph{Erstellung durch Vererbung} % (fold)
\label{par:enumeratorerstellung_durch_vererbung}\mbox{} % force new line

Bei der Erstellung eines \lstinline|Enumerator|s durch Vererbung, muss das \lstinline|Enumerator|-Trait implementiert werden.
Alles, was dafür nötig ist, ist die \lstinline|apply|-Methode zu implementieren.
Innerhalb dieser Methode wird der übergebene \lstinline|Iteratee| mit Hilfe seiner \lstinline|fold|-Methode befüllt, wie in Listing~\ref{lst:enumeratorerstellung_durch_vererbung} zu sehen.

\begin{lstlisting}[caption=Erstellung eines Enumerators durch Vererbung, label=lst:enumeratorerstellung_durch_vererbung]
case class NumberEnumerator(xs: Int*) extends Enumerator[Int] {
  def apply[A](iteratee: Iteratee[Int, A]):
      Future[Iteratee[Int, A]] = {
    xs.foldLeft(Future(iteratee)) { (futureIteratee, x) =>
      futureIteratee.flatMap { iteratee =>
        iteratee.fold {
          case Step.Cont(k) => Future(k(Input.El(x)))
          case _ => Future(iteratee)
        }
      }
    }
  }
}

val numberEnumeratorFromInheritance: Enumerator[Int] =
  NumberEnumerator(22, 25, 54)
\end{lstlisting}

Alles was ein \lstinline|Enumerator| zu tun hat, ist seine Daten an den übergebenen \lstinline|Iteratee| zu übergeben.
Dieses Vorgehen ist in diesem Beispiel als Fold über den \lstinline|Iteratee| implementiert.
Es wird immer ein Element an den \lstinline|Iteratee| übergeben und der resultierende \lstinline|Iteratee| als neues Zwischenergebnis verwendet.
Falls der \lstinline|Iteratee| keine weiteren Elemente akzeptiert, obwohl noch Elemente übrig sind, wird dieser als Endergebnis verwendet.
Das hier vorgestellte Verfahren ist in leicht abgewandelter Form der Implementierung von \lstinline|Enumerator.apply| entnommen \cite[vgl.][Z.~611 und Z.~654]{play_enumerator_source_code}.

% paragraph enumeratorerstellung_durch_vererbung (end)

\paragraph{Erstellung durch Konstruktormethode im Companion-Objekt} % (fold)
\label{par:erstellung_durch_konstruktormethode_im_companion-object}\mbox{} % force new line

Die zweite Variante, einen \lstinline|Enumerator| zu erstellen, ist mit Hilfe einer der Konstruktormethoden des Companion-Objekts.
Hierfür gibt es mehrere hilfreiche Methoden, die an dieser Stelle aber nicht alle vorgestellt werden können.
Stattdessen wird exemplarisch eine Methode vorgestellt, die auch in den folgenden Beispielen verwendet werden wird.

Die hier vorgestellte Methode ist die \lstinline|apply|-Methode des Companion-Objekts mit der Signatur \lstinline[breaklines=true]|def apply[E](in: E*): Enumerator[E]|.
Diese Methode nimmt als Parameter beliebig viele Elemente eines Typs und wird diese bei Anwendung in \lstinline|Input|-Elemente verpacken und an den \lstinline|Iteratee| übergeben.
Wie der \lstinline|Enumerator| mit dieser Methode erstellt wird, ist in Listing~\ref{lst:enumeratorerstellung_durch_apply} zu sehen.

\begin{lstlisting}[caption=Erstellung eines Enumerators durch die apply-Konstruktormethode, label=lst:enumeratorerstellung_durch_apply]
val numberEnumeratorFromApply: Enumerator[Int] =
  Enumerator(22, 25, 54)
\end{lstlisting}

% paragraph erstellung_durch_konstruktormethode_im_companion-object (end)

\paragraph{Erstellung durch Konstruktormethode im Concurrent-Objekt} % (fold)
\label{par:erstellung_durch_konstruktormethode_im_concurrent_objekt}\mbox{} % force new line

Das Objekt \lstinline|Concurrent| stellt weitere Konstruktoren für \lstinline|Enumerator|s bereit.
Unter anderem beinhaltet dieses Objekt die Methode \lstinline|broadcast|, die imperatives schreiben auf einen oder mehrere \lstinline|Iteratee|s erlaubt.
\lstinline|broadcast| nimmt keine Argumente und gibt \lstinline|(Enumerator[E], Channel[E])| zurück.
Mit Hilfe des \lstinline|Channel|s können imperativ Daten an den \lstinline|Enumerator| übergeben werden.
Ein \lstinline|Channel| hat u.~a. die Methoden \lstinline|def push(item: E): Unit| und \lstinline|def end(): Unit|.
Diese Methoden erlauben es, ein Element an die verbundenen \lstinline|Iteratee|s zu übergeben, bzw. zu signalisieren, dass der \lstinline|Enumerator| keine weiteren Elemente mehr hat.

Listing~\ref{lst:enumeratorerstellung_durch_broadcast} zeigt, wie \lstinline|Concurrent.broadcast| verwendet werden kann.
Zu beachten ist hierbei, dass ein verbundener \lstinline|Iteratee| nur die Elemente empfängt, die an den \lstinline|Enumerator| übergeben wurden, nachdem der \lstinline|Iteratee| mit dem \lstinline|Enumerator| verbunden wurde.
Alte Elemente werden vom \lstinline|Enumerator| nicht für neue \lstinline|Iteratee|s gespeichert.
Nach Übergabe aller Zahlen muss der \lstinline|Channel| wieder geschlossen werden, andernfalls wird niemals signalisiert, dass keine weiteren Elemente mehr kommen und verbundene \lstinline|Iteratee|s werden nicht in den \lstinline|Step.Done|-Zustand übergehen.
In Unterabschnitt~\ref{sub:server_sent_events_in_der_altersstatistiken_anwendung} im \nameref{cha:real_time_web}-Kapitel wird die hier beschriebene Methode verwendet, um mittels Server Sent Events die Altersangaben an alle verbundenen Clients zu verbreiten.

\begin{lstlisting}[caption=Erstellung eines Enumerators durch die broadcast-Konstruktormethode, label=lst:enumeratorerstellung_durch_broadcast]
val (numberEnumeratorFromBroadcast, broadcastChannel) =
  Concurrent.broadcast[Int]

// Iteratee(s) mit numberEnumeratorFromBroadcast verbinden

broadcastChannel.push(22)
broadcastChannel.push(25)
broadcastChannel.push(54)
broadcastChannel.end()
\end{lstlisting}

% paragraph erstellung_durch_konstruktormethode_im_concurrent_objekt (end)

% subsubsection enumerators_erstellen (end)

\subsubsection{Anwendung auf Iteratees} % (fold)
\label{ssub:anwendung_auf_iteratees}

\lstinline|Enumerator|s sind, wie in Unterabschnitt~\ref{sub:design_enumerators} erklärt, Funktionen.
Das Ergebnis der Anwendung einer solchen \lstinline|Enumerator|-Funktion ist der übergebene \lstinline|Iteratee| nach Konsum der Elemente in der \lstinline|Future|-Monade.
Ein Beispiel für diese ersten Schritte ist in Listing~\ref{lst:enumeratoranwendung1} zu sehen.

\begin{lstlisting}[caption=Anwendung eines Enumerators auf einen Iteratee, label=lst:enumeratoranwendung1]
val iteratee: Iteratee[Int, Int] = Iteratee.fold(0)(_ + _)
val enumerator: Enumerator[Int] = Enumerator(22, 25, 54)
val futureIterateeAfterApplication: Future[Iteratee[Int, Int]] =
  enumerator(iteratee)
\end{lstlisting}


Um mit dem neuen \lstinline|Iteratee| weiterzuarbeiten wäre es möglich, alle weiteren Operationen innerhalb der \lstinline|Future|-Monade durchzuführen.
Weil es aber eine Indirektion bedeuten würde, \lstinline|Iteratee|s innerhalb von \lstinline|Future|s zu bearbeiten, ist es möglich einen Wert vom Typ \lstinline|Future[Iteratee[E, A]]| in einen Wert vom Typ \lstinline|Iteratee[E, A]| zu transformieren.
Beide Typen haben die gleiche Bedeutung, indem sie für ein Ergebnis stehen, das möglicherweise noch nicht vorhanden ist.
Weil ein \lstinline|Iteratee| innerhalb der \lstinline|Future|-Monade aus diesem Betrachtungswinkel aber redundant ist, existiert die Methode \lstinline|Iteratee.flatten|, um diese Transformation durchzuführen.


Nachdem ein \lstinline|Enumerator| alle Elemente an einen \lstinline|Iteratee| übergeben hat, sendet er allerdings kein \lstinline|Input.EOF|-Element.
Dadurch ist es möglich, mehrere \lstinline|Enumerator|s auf einen \lstinline|Iteratee| anzuwenden, worauf in Unterabschnitt~\ref{ssub:anwendung_sequentielle_komposition_von_enumerators} näher eingegangen wird.
Um ein \lstinline|Input.EOF|-Element an einen \lstinline|Iteratee| zu senden und anschließend das berechnete Ergebnis zu erhalten, wird die \lstinline|run|-Methode aus dem \lstinline|Iteratee|-Trait aufgerufen.
Eine Weiterführung des zuvor begonnenen \lstinline|Enumerator|-Beispiels ist in Listing~\ref{lst:enumeratoranwendung2} zu finden.
In diesem Beispiel werden die beiden oben beschriebenen Techniken angewendet, um die berechnete Summe aus dem \lstinline|Iteratee| zu extrahieren.

\begin{lstlisting}[caption=Extrahierung des Ergebnisses aus einem Iteratee, label=lst:enumeratoranwendung2]
val iterateeAfterApplication: Iteratee[Int, Int] =
  Iteratee.flatten(futureIterateeAfterApplication)

val futureResult: Future[Int] = iterateeAfterApplication.run
// futureResult hat den Wert Future(101)
\end{lstlisting}

Mit Hilfe der Methode \lstinline|Enumerator.run| ist es außerdem möglich, \lstinline|Enumerator|anwendung und Ergebnisextraktion zusammenzufassen.
Diese Methode hat die Signatur \lstinline[breaklines=true]|def run[A](i: Iteratee[E, A]): Future[A]|.
Unter Einsatz dieser Methode wird die Verarbeitung im Aufsummierungsbeispiel, wie in Listing~\ref{lst:enumeratoranwendung3} zu sehen, auf einen Befehl verkürzt.

\begin{lstlisting}[caption=Anwendung eines Enumerators mit gleichzeitiger Ergebnisextrahierung, label=lst:enumeratoranwendung3]
val futureResult2: Future[Int] = enumerator.run(iteratee)
// futureResult2 hat den Wert Future(101)
\end{lstlisting}

% subsubsection anwendung_auf_iteratees (end)

% subsection enumerators (end)


\subsection{Anwendung von Enumeratees} % (fold)
\label{sub:enumeratees}

\lstinline|Enumeratee|s sind Stream-Transformatoren, die \lstinline|Iteratee|s eines Typs zu \lstinline|Iteratee|s eines anderen Typs transformieren.
Sie sind, wie in Unterabschnitt~\ref{sub:design_enumeratees} erklärt, Funktionen von \lstinline|Iteratee| nach \lstinline|Iteratee|.
Das Ergebnis des resultierenden \lstinline|Iteratee|s ist wiederum ein \lstinline|Iteratee|.
Und zwar ist es der ursprüngliche \lstinline|Iteratee| nach Empfang der Elemente.
Plays \lstinline|Enumeratee|s ermöglichen es allerdings auch \lstinline|Enumerator|s und andere \lstinline|Enumeratee|s zu transformieren.
In diesem Unterabschnitt wird beschrieben, wie eigene \lstinline|Enumeratee|s erstellt und wie sie auf \lstinline|Iteratee|s, \lstinline|Enumerator|s und \lstinline|Enumeratee|s angewendet werden können.

\subsubsection{Erstellung von Enumeratees} % (fold)
\label{ssub:erstellung_von_enumeratees}

Es gibt drei Möglichkeiten, einen \lstinline|Enumeratee| zu erstellen.

\begin{enumerate}
  \item Durch Erstellung einer neuen Klasse, die das \lstinline|Enumeratee|-Trait implementiert.
  \item Durch Benutzung einer Konstruktormethode des Companion-Objekts (\lstinline|map|, \lstinline|filter|, u.~a.)
  \item Durch Benutzung einer Konstruktormethode des \lstinline|Traversable|-Objekts aus dem \lstinline|play.api.libs.iteratee|-Paket (\lstinline|take|, \lstinline|drop|, u.~a.)
\end{enumerate}

Im Folgenden werden die ersten beiden Möglichkeiten vorgestellt und mit Beispielen veranschaulicht.
Die dritte Möglichkeit ist an dieser Stelle nur der Vollständigkeit halber aufgeführt, weil sie vom Autor als zu speziell erachtet wird.
Es sei hier nur erwähnt, dass das \lstinline|Traversable|-Objekt einige wenige Konstruktormethoden für \lstinline|Enumeratee|s bereitstellt, die auf Elementen vom Typ \lstinline|TraversableLike| aus der Scala-Standardbibliothek arbeiten.
Um die Altersstatistik zu schönen, sollen alle Altersangaben ab 50 um zehn Jahre verjüngt werden.
In den Beispielen wird ein \lstinline|Enumeratee| implementiert, der die eingehenden Zahlen auf die festgelegte Altersgrenze hin überprüft und gegebenenfalls angepasst an den inneren \lstinline|Iteratee[Int, Int]| weiterleitet.

\paragraph{Erstellung durch Vererbung} % (fold)
\label{par:enumerateeerstellung_durch_vererbung}\mbox{} % force new line

Das \lstinline|Enumeratee|-Trait verlangt, dass die Methode \lstinline|applyOn| implementiert wird.
Die Methode \lstinline|apply| ist als Alias für \lstinline|applyOn| definiert.
\lstinline|applyOn| hat die Signatur, die in Unterabschnitt~\ref{sub:design_enumeratees} für \lstinline|apply| vorgestellt wurde.
Eine Mögliche Implementierung für einen \lstinline|Enumeratee|, der die Zahlen eines \lstinline|Iteratee|s anpasst, ist in Listing~\ref{lst:enumerateeerstellung_durch_vererbung} zu sehen.

\begin{lstlisting}[caption=Erstellung eines Enumeratees durch Vererbung, label=lst:enumerateeerstellung_durch_vererbung]
case object RejuvinatingEnumeratee extends Enumeratee[Int, Int] {
  def applyOn[A](inner: Iteratee[Int, A]):
      Iteratee[Int, Iteratee[Int, A]] =
    Iteratee.flatten(inner.fold {
      case Step.Cont(k) => Future(Cont {
        case Input.El(number) if number >= 50 =>
          RejuvinatingEnumeratee(k(Input.El(number - 10)))
        case Input.El(number) =>
          RejuvinatingEnumeratee(k(Input.El(number)))
        case Input.Empty => RejuvinatingEnumeratee(k(Input.Empty))
        case Input.EOF => Done(Cont(k))
      })
      case _ => Future(Done(inner, Input.Empty))
    })
}

val enumerateeFromInheritance: Enumeratee[Int, Int] =
  RejuvinatingEnumeratee
\end{lstlisting}

Die Implementierung dieses \lstinline|Enumeratee|s ist der von \lstinline|Enumeratee.map| nachempfunden.
Sie ist allerdings weniger abstrakt, als in der Referenzimplementierung \cite[vgl.][Z.~372, Z.~196 und Z.~85]{play_enumeratee_source_code}.
Der \lstinline|Enumeratee| prüft, ob der innere \lstinline|Iteratee| weitere Elemente annehmen kann.
Kann er keine weiteren Elemente annehmen, wird er als Ergebnis zurückgegeben.
Kann er Elemente annehmen, werden diese transformiert und anschließend weitergegeben.
Sobald ein \lstinline|Input.EOF| empfangen wird, wird in den Endzustand mit dem finalen inneren \lstinline|Iteratee| als Ergebnis übergegangen.

% paragraph enumerateeerstellung_durch_vererbung (end)

\paragraph{Erstellung durch Konstruktormethode des Companion-Objekts} % (fold)
\label{par:enumerateeerstellung_durch_konstruktormethode_des_companion_objekts}\mbox{} % force new line

Die zweite hier vorgestellte Möglichkeit, einen \lstinline|Enumeratee| zu erstellen ist mit Hilfe seines Companion-Objekts.
Im Companion-Objekt finden sich mehrere Konstruktormethoden, die Listenoperationen sehr ähneln, wie z.~B. \lstinline|drop|, \lstinline|filter|, \lstinline|map| oder \lstinline|zip|.
Um alle Elemente des \lstinline|Iteratees| zu transformieren bietet sich \lstinline|map| an.
Mit Hilfe dieser Methode werden alle Elemente durch eine angegebene Funktion transformiert, bevor sie an das innere \lstinline|Iteratee| gegeben werden.
\lstinline|map| hat folgende Signatur \cite[vgl.][Z.~361]{play_enumeratee_source_code}:
\begin{lstlisting}[caption=Die Signatur von Enumeratee.map, label=lst:die_signatur_von_enumeratee_map]
trait Map[E] {
  def apply[NE](f: E => NE)(implicit ec: ExecutionContext):
    Enumeratee[E, NE]
}

def map[E]: Map[E]
\end{lstlisting}
Diese Signatur wirkt sperrig, lässt sich aber sinngemäß auf folgende Vereinfachung reduzieren:
\begin{lstlisting}[caption=Die vereinfachte Signatur von Enumeratee.map, label=lst:die_vereinfachte_signatur_von_enumeratee_map]
def map[E, NE](f: E => NE): Enumeratee[E, NE]
\end{lstlisting}

Der wichtige Unterschied zwischen diesen beiden Signaturen ist, dass die erste nur über einen Typ \lstinline|E| parametrisiert ist.
Erst das zurückgegebene Objekt verlangt den zweiten Typ \lstinline|NE|.
Dadurch wird, so vermutet der Autor, Code, der diese Methode nutzt, kürzer, weil der Parameter \lstinline|NE| in der Regel vom Compiler abgeleitet werden kann.
So muss in aller Regel, sofern überhaupt nötig, nur noch der erste Typ-Parameter angegeben werden.
Zu einem früheren Entwicklungsstand des Frameworks wurde die zweite Variante verwendet und wurde erst später zur aktuellen Signatur abgeändert \cite[vgl.][]{play_enumeratee_map_signatur}.
Der implizite \lstinline|ExecutionContext|-Parameter wird wieder für die interne Arbeit mit \lstinline|Future|s benötigt.

Unter Einsatz dieser \lstinline|map|-Methode ist die Transformation in einer einzigen Anweisung möglich.
Der dazu nötige Code kann Listing~\ref{lst:enumerateeerstellung_durch_companion_konstruktormethode} entnommen werden.

\begin{lstlisting}[caption=Erstellung eines Enumeratees durch die map-Konstruktormethode, label=lst:enumerateeerstellung_durch_companion_konstruktormethode]
val enumerateeFromConstructor: Enumeratee[Int, Int] =
  Enumeratee.map(x => if (x >= 50) x - 10 else x)
\end{lstlisting}

% paragraph enumerateeerstellung_durch_konstruktormethode_des_companion_objekts (end)

% subsubsection erstellung_von_enumeratees (end)

\subsubsection{Anwendung auf Iteratees} % (fold)
\label{ssub:enumerateeanwendung_auf_iteratees}

Für die Anwendung auf \lstinline|Iteratee|s eignet sich die \lstinline|apply|-, bzw. die \lstinline|applyOn|-Methode, die im Unterabschnitt~\nameref{par:enumerateeerstellung_durch_vererbung} implementiert wurde.
Der Rückgabewert dieser Methode ist ein verschachtelter \lstinline|Iteratee|, nämlich der äußere und der innere \lstinline|Iteratee|.
Dies ermöglicht es, nach Beendigung des äußeren \lstinline|Iteratee|s wieder den ursprünglichen \lstinline|Iteratee| nach Empfang der transformierten Elemente zu erhalten.
Für den Fall, dass der ursprüngliche \lstinline|Iteratee| nicht wiederverwendet werden soll, gibt es die Methode \lstinline|transform|.
\lstinline|transform| gibt nach Anwendung nur den tranfsormierten \lstinline|Iteratee| zurück.
Listing~\ref{lst:enumerateeanwendung_auf_iteratees} zeigt, wie ein \lstinline|Enumeratee| auf einen \lstinline|Iteratee| angewendet werden und anschließend wieder mit dem ursprünglichen \lstinline|Iteratee| weitergearbeitet werden kann.

\begin{lstlisting}[caption=Enumerateeanwendung auf Iteratees, label=lst:enumerateeanwendung_auf_iteratees]
val t: Enumeratee[Int, Int] =
  Enumeratee.map(x => if (x >= 50) x - 10 else x)
val i: Iteratee[Int, List[Int]] = Iteratee.getChunks
val e: Enumerator[Int] = Enumerator(22, 54)

val transformedI: Iteratee[Int, Iteratee[Int, List[Int]]] = t(i)
val originalI: Iteratee[Int, List[Int]] =
  Iteratee.flatten(e.run(transformedI))

val result: Future[List[Int]] = e.run(originalI)
// result hat den Wert Future(List(22, 44, 22, 54))
\end{lstlisting}

Der transformierende \lstinline|Enumeratee| wird auf den konsumierenden \lstinline|Iteratee| angewendet (Z.~6).
Daraufhin werden alle generierten Elemente des \lstinline|Enumerator|s angepasst, bevor sie an den \lstinline|Iteratee| gelangen.
Der \lstinline|Enumerator| sendet einmal die Elemente an den transformierten \lstinline|Iteratee| (Z.~8) und einmal an den ursprünglichen \lstinline|Iteratee| (Z.~10).
Am Ergebnis ist zu erkennen, dass die Elemente im ersten Fall korrekt transformiert und im zweiten Fall unverändert übergeben wurden.

% subsubsection enumerateeanwendung_auf_iteratees (end)

\subsubsection{Anwendung auf Enumerators} % (fold)
\label{ssub:enumerateeanwendung_auf_enumerators}

Neben \lstinline|Iteratee|s können auch \lstinline|Enumerator|s transformiert werden.
Dafür stellt das \lstinline|Enumerator|-Trait die Methode \lstinline|through| bereit.
\lstinline|through| nimmt als Argument einen \lstinline|Enumeratee| und gibt als Rückgabewert einen neuen \lstinline|Enumerator| zurück.

% subsubsection enumerateeanwendung_auf_enumerators (end)

\subsubsection{Anwendung auf Enumeratees} % (fold)
\label{ssub:enumerateeanwendung_auf_enumeratees}

\lstinline|Enumeratee|s können auch auf andere \lstinline|Enumeratee|s angewendet werden, wodurch sich eine Kette von Transformationen abbilden lässt.
Mit Hilfe der Methode \lstinline|compose| oder dem Operator \lstinline|><>| lassen sich zwei \lstinline|Enumeratee|s verketten.
Die Signatur von \lstinline|compose| ist Listing~\ref{lst:die_signatur_von_compose} zu entnehmen.
\begin{lstlisting}[caption=Die Signatur von compose, label=lst:die_signatur_von_compose]
def compose[To2](other: Enumeratee[To, To2]): Enumeratee[From,To2]
\end{lstlisting}

In Listing~\ref{lst:enumerateeanwendung_auf_enumeratees} ist ein Beispiel zu sehen, in dem zwei \lstinline|Enumeratees| verkettet werden.
Der erste \lstinline|Enumeratee| sorgt dafür, dass Personen ab 70 gar nicht mehr in der Altersstatistik auftauchen, indem der Stream mit Hilfe von \lstinline|Enumeratee.filter| auf die kleineren Zahlen reduziert wird.
Der zweite \lstinline|Enumeratee| transformiert die übriggebliebenen Elemente wie zuvor so, dass alle Personen ab 50 um 10 Jahre jünger gemacht werden.
Anschließend werden beide \lstinline|Enumeratee|s kombiniert und auf einen \lstinline|Enumerator| angewendet, sodass schon transformierte Elemente generiert werden.
Im Ergebnis ist gut zu erkennen, dass der \lstinline|Iteratee| nur die Altersangaben unter 50 unverändert empfängt.

\begin{lstlisting}[caption=Enumerateeanwendung auf Enumeratees, label=lst:enumerateeanwendung_auf_enumeratees]
val t1: Enumeratee[Int, Int] = Enumeratee.filter(_ < 70)
val t2: Enumeratee[Int, Int] =
  Enumeratee.map(x => if (x >= 50) x - 10 else x)
val t12: Enumeratee[Int, Int] = t1.compose(t2)

val e: Enumerator[Int] = Enumerator(22, 25, 54, 76)
val i: Iteratee[Int, List[Int]] = Iteratee.getChunks

val result: Future[List[Int]] = e.through(t12).run(i)
// result hat den Wert Future(List(22, 25, 44))
\end{lstlisting}

% subsubsection enumerateeanwendung_auf_enumeratees (end)

% subsection enumeratees (end)


\subsection{Anwendung von Komposition} % (fold)
\label{sub:anwendung_komposition}

Die in Unterabschnitt~\ref{sub:komposition} vorgestellten Arten von Komposition sollen an dieser Stelle durch Anwendungsbeispiele veranschaulicht werden.
Dabei wird auf die sequentielle und parallele Komposition von \lstinline|Iteratee|s und \lstinline|Enumerator|s eingegangen.

\subsubsection{Sequentielle Komposition von Iteratees} % (fold)
\label{ssub:anwendung_sequentielle_komposition_von_iteratees}

Zwei \lstinline|Iteratee|s sequentiell zu kombinieren, bedeutet zuerst den ersten \lstinline|Iteratee| auszuführen, bis er keine Elemente mehr annimmt oder die Datenquelle erschöpft ist und dann den zweiten \lstinline|Iteratee| nach dem gleichen Prinzip auszuführen.
Dafür eignen sich die Methoden \lstinline|map| und \lstinline|flatMap| des \lstinline|Iteratee|-Traits.
Diese Methoden erlauben es, wie bei jeder Monade, den Wert innerhalb der Monade zu transformieren.
Der Wert der \lstinline|Iteratee|-Monade steht fest, sobald der \lstinline|Iteratee| in den \lstinline|Done|-Zustand übergegangen ist.
Dies geschieht, nachdem der \lstinline|Iteratee| die für ihn erforderlichen Elemente empfangen und daraus ein Ergebnis berechnet hat.
Um zwei \lstinline|Iteratee|s nacheinander auszuführen, wird zuerst per \lstinline|flatMap| auf den berechneten Wert des ersten \lstinline|Iteratee|s zugegriffen.
Anschließend wird ein \lstinline|map| über den zweiten \lstinline|Iteratee| durchgeführt, um an das zweite Ergebnis zu gelangen und beide Ergebnisse zu kombinieren.
Ein Code-Beispiel, das dieses Prinzip ausnutzt, ist in Listing~\ref{lst:sequentielle_komposition_von_iteratees} zu lesen.

\begin{lstlisting}[caption=Sequentielle Komposition von Iteratees, label=lst:sequentielle_komposition_von_iteratees]
val i1: Iteratee[Int, Option[Int]] = Iteratee.head
val i2: Iteratee[Int, Int] = Iteratee.fold(0)(_ + _)

val i12: Iteratee[Int, (Option[Int], Int)] =
  i1.flatMap(res1 => i2.map(res2 => (res1, res2)))

val e: Enumerator[Int] = Enumerator(1, 4, -2)
val result: Future[(Option[Int], Int)] = e.run(i12)
// result hat den Wert Future((Some(1), 2))
\end{lstlisting}

In diesem Fall gibt es zwei \lstinline|Iteratee|s.
Der erste \lstinline|Iteratee| konsumiert genau ein Element und gibt dieses, in einem \lstinline|Option|-Wert verpackt, zurück.
Der \lstinline|Option|-Typ ist notwendig, damit auch ein Ergebnis existiert, wenn nur ein \lstinline|Input.EOF|, aber kein \lstinline|Input.El| empfangen wird.
Der zweite \lstinline|Iteratee| summiert alle empfangenen Elemente auf und gibt die Summe als Ergebnis zurück.
Das Ergebnis der Komposition dieser beiden \lstinline|Iteratee|s ist ein Paar aus dem Ergebnis des ersten und des zweiten \lstinline|Iteratee|s.
Das Kombinieren von \lstinline|i1| und \lstinline|i2| lässt sich durch das Verwenden einer \lstinline|for|-Comprehension allerdings noch lesbarer gestalten, wie in Listing~\ref{lst:sequentielle_komposition_von_iteratees_mit_for_comprehension} zu sehen.

\begin{lstlisting}[caption=Sequentielle Komposition von Iteratees mit for-Comprehension, label=lst:sequentielle_komposition_von_iteratees_mit_for_comprehension]
val i12: Iteratee[Int, (Option[Int], Int)] = for {
  res1 <- i1
  res2 <- i2
} yield (res1, res2)
\end{lstlisting}

% subsubsection anwendung_sequentielle_komposition_von_iteratees (end)

\subsubsection{Parallele Komposition von Iteratees: eine Quelle auf mehrere Senken} % (fold)
\label{ssub:anwendung_parallele_komposition_von_iteratees_eine_quelle}

Bei der parallelen Komposition zweier \lstinline|Iteratee|s werden die Elemente der Datenquelle an beide \lstinline|Iteratee|s übergeben.
Eine Datenquelle auf mehrere Datensenken abzubilden, lässt sich mit Hilfe von \lstinline|Enumeratee|s und den Methoden \lstinline|zip|, bzw. \lstinline|zipWith| bewerkstelligen.
\lstinline|zip| erstellt aus zwei \lstinline|Iteratee|s einen neuen \lstinline|Iteratee|, der die empfangen Elemente an beide \lstinline|Iteratee|s weitergibt.
Die genaue Signatur von \lstinline|Enumeratee.zip| ist Listing~\ref{lst:signatur_enumeratee_zip} zu entnehmen.

\begin{lstlisting}[caption=Die Signatur von Enumeratee.zip, label=lst:signatur_enumeratee_zip]
def zip[E, A, B](inner1: Iteratee[E, A], inner2: Iteratee[E, B]):
  Iteratee[E, (A, B)]
\end{lstlisting}

Sobald beide \lstinline|Iteratee|s im \lstinline|Done|-Zustand sind, werden die Ergebnisse als Paar zurückgegeben.
Falls ein \lstinline|Iteratee| in den \lstinline|Error|-Zustand übergeht, ist auch der resultierende \lstinline|Iteratee| im \lstinline|Error|-Zustand.
Die Verwendung von \lstinline|zipWith| ermöglicht es, das Ergebnis nicht nur als Paar zu erhalten, sondern es kann eine Funktion übergeben werden, die die Ergebnisse zu einem beliebigen Datentyp zusammenfasst.
In Listing~\ref{lst:parallele_komposition_von_iteratees_mit_einer_Quelle_auf_mehrere_senken} ist ein Beispiel zu sehen, das die beiden \lstinline|Iteratee|s aus dem Beispiel für \nameref{lst:sequentielle_komposition_von_iteratees} verwendet, sie aber parallel kombiniert.

\begin{lstlisting}[caption=Parallele Komposition von Iteratees mit einer Quelle und mehreren Senken, label=lst:parallele_komposition_von_iteratees_mit_einer_Quelle_auf_mehrere_senken]
val i1: Iteratee[Int, Option[Int]] = Iteratee.head
val i2: Iteratee[Int, Int] = Iteratee.fold(0)(_ + _)

val i12: Iteratee[Int, (Option[Int], Int)] =
  Enumeratee.zip(i1, i2)

val e: Enumerator[Int] = Enumerator(1, 4, -2)
val result: Future[(Option[Int], Int)] = e.run(i12)
// result hat den Wert Future((Some(1), 3))
\end{lstlisting}

% subsubsection anwendung_parallele_komposition_von_iteratees_eine_quelle (end)

\subsubsection{Parallele Komposition von Iteratees: mehrere Quellen auf eine Senke} % (fold)
\label{ssub:anwendung_parallele_komposition_von_iteratees_mehrere_quellen}

Es können auch mehrere \lstinline|Enumerator|s auf einen \lstinline|Iteratee| angewendet werden.
Ein auf diese Weise zusammengesetzter \lstinline|Iteratee| ist ein verschachtelter \lstinline|Iteratee|, wobei der äußere \lstinline|Iteratee| als Ergebnis einen inneren \lstinline|Iteratee| zurückliefert, der von einem weiteren \lstinline|Enumerator| Elemente benötigt.
Wie ein solcher \lstinline|Iteratee| aussieht, ist in Listing~\ref{lst:parallele_komposition_von_iteratees_mit_mehreren_quellen_auf_eine_senke} zu sehen.
\lstinline|headHeadIteratee| ist ein \lstinline|Iteratee|, der von zwei \lstinline|Enumerator|s liest und das jeweils erste Element zurückgibt.
Um einen verschachtelten \lstinline|Iteratee| auszuführen, müssen die \lstinline|Iteratee|s der einzelnen Ebenen nacheinander ausgeführt werden, was an den Variablen \lstinline|intermediateResult| und \lstinline|result| zu erkennen ist.

\begin{lstlisting}[caption=Parallele Komposition von Iteratees mit mehreren Quellen auf eine Senke, label=lst:parallele_komposition_von_iteratees_mit_mehreren_quellen_auf_eine_senke]
def headHeadIteratee[A, B]:
  Iteratee[A, Iteratee[B, (Option[A], Option[B])]] =
    Iteratee.head.map(a => Iteratee.head.map(b => (a, b)))

val i:
  Iteratee[Char, Iteratee[Int, (Option[Char], Option[Int])]] =
    headHeadIteratee[Char, Int]
val e1: Enumerator[Char] = Enumerator('1', '2', '3')
val e2: Enumerator[Int] = Enumerator()

val intermediateResult:
  Iteratee[Int, (Option[Char], Option[Int])] =
    Iteratee.flatten(e1.run(i))

val result: Future[(Option[Char], Option[Int])] =
  e2.run(intermediateResult)
// result hat den Wert Future((Some('1'), None))
\end{lstlisting}

% subsubsection anwendung_parallele_komposition_von_iteratees_mehrere_quellen (end)

\subsubsection{Sequentielle Komposition von Enumerators} % (fold)
\label{ssub:anwendung_sequentielle_komposition_von_enumerators}

\begin{sloppypar} % larger word spacing so that \lstinline will not go out of line margin
Sequentielle Komposition zweier \lstinline|Enumerator|s heißt, dass erst die Elemente des ersten \lstinline|Enumerator|s generiert werden, bis dieser erschöpft ist und anschließend die Elemente des zweiten \lstinline|Enumerator|s generiert werden.
Das \lstinline|Enumerator|-Trait stellt hierfür die Methode \lstinline|andThen| mit der Signatur \lstinline[breaklines=true]|Enumerator[E] => Enumerator[E]| bereit.
Diese Methode erstellt einen neuen \lstinline|Enumerator|, der die Elemente des ursprünglichen \lstinline|Enumerator|s und dann die Elemente des übergebenen \lstinline|Enumerator|s enumeriert.
Listing~\ref{lst:sequentielle_komposition_von_enumerators} zeigt, wie \lstinline|andThen| verwendet werden kann, um zwei \lstinline|Enumerator|s sequentiell zu komponieren.
\end{sloppypar}

\begin{lstlisting}[caption=Sequentielle Komposition von Enumerators, label=lst:sequentielle_komposition_von_enumerators]
val i: Iteratee[Int, List[Int]] = Iteratee.getChunks
val e1 = Enumerator(1, 2)
val e2 = Enumerator(3)
val e12: Enumerator[Int] = e1.andThen(e2)

val result: Future[List[Int]] = e12.run(i)
// result hat den Wert Future(List(1, 2, 3))
\end{lstlisting}

% subsubsection anwendung_sequentielle_komposition_von_enumerators (end)

\subsubsection{Parallele Komposition von Enumerators} % (fold)
\label{ssub:anwendung_parallele_komposition_von_enumerators}

Wenn immer das zuerst verfügbare Element zweier \lstinline|Enumerator|s generiert werden soll, wird dies als parallele Komposition bezeichnet.
Das \lstinline|Enumerator|-Companion-Objekt stellt hierfür die Konstruktormethode \lstinline|interleave| bereit.
\lstinline|interleave| kommt in unterschiedlichen Varianten, darunter auch in einer Variante mit der in Listing~\ref{lst:signatur_von_interleave} gezeigten Signatur.

\begin{lstlisting}[caption=Die Signatur von interleave, label=lst:signatur_von_interleave]
def interleave[E](e1: Enumerator[E], es: Enumerator[E]*):
  Enumerator[E]
\end{lstlisting}

\lstinline|interleave| nimmt einen oder mehrere \lstinline|Enumerator|s als Argumente und kombiniert diese nach dem zuvor beschriebenen Prinzip.
In Listing~\ref{lst:parallele_komposition_von_enumerators} wird mit Hilfe dieser Methode gezeigt, wie mehrere \lstinline|Enumerator|s parallel komponiert werden können.

\begin{lstlisting}[caption=Parallele Komposition von Enumerators, label=lst:parallele_komposition_von_enumerators]
def timeoutEnumerator[A](x: A, d: Duration): Enumerator[A] =
  Enumerator.flatten(Promise.timeout(Enumerator(x), d))

val i: Iteratee[Int, List[Int]] = Iteratee.getChunks
val e1 = timeoutEnumerator(1, 3 seconds)
val e2 = timeoutEnumerator(2, 1 second)
val e3 = timeoutEnumerator(3, 2 seconds)
val e123: Enumerator[Int] = Enumerator.interleave(e1, e2, e3)

val result: Future[List[Int]] = e123.run(i)
// result hat den Wert Future(List(2, 3, 1))
\end{lstlisting}

Zu bemerken ist hierbei, dass Play das Objekt \lstinline|play.api.libs.concurrent.Promise| mit mehreren Hilfsmethoden zur Verfügung stellt.
Mit dessen \lstinline|timeout|-Methode ist es möglich, ein \lstinline|Future|-Objekt zu erstellen, dass nach Verlauf einer angegebenen Zeitspanne einen Wert liefert.
\lstinline|Enumerator.flatten| transformiert einen Wert vom Typ \lstinline|Future[Enumerator[A]]| nach \lstinline|Enumerator[A]| analog zur Methode \lstinline|Iteratee.flatten|, die in Unterabschnitt~\ref{ssub:anwendung_auf_iteratees} behandelt wurde.
Gut zu erkennen ist, dass die Reihenfolge der Elemente im Ergebnis mit der jeweiligen Zeitspanne korreliert und nicht etwa mit der Reihenfolge, in der die \lstinline|Enumerator|s an \lstinline|interleave| übergeben wurden.

% subsubsection anwendung_parallele_komposition_von_enumerators (end)

% subsection anwendung_komposition (end)


\subsection{Gesetze} % (fold)
\label{sub:iteratee_gesetze}

Kiselyov identifiziert in \citealt{kiselyov2012}~(S.~12--13 u. S.~18--21) mehrere Gesetze für Iteratee-Streams, die Beweise über Code ermöglichen, der diese Streams verwendet.
Zur besseren Lesbarkeit werden in Listing~\ref{lst:verwendete_typ_aliase} einige Typ-Aliase eingeführt, die in den Gesetzesdefinitionen verwendet werden.

\begin{lstlisting}[caption=Typ-Aliase der Gesetze, label=lst:verwendete_typ_aliase]
type E     = Char           // Der Eingabeelementtyp (Char)
type I[A]  = Iteratee[E, A] // Ein Iteratee von Char nach A
type M[A]  = Future[A]      // Die Monade (Future)
type IM[A] = M[I[A]]        // Ein Iteratee in der Future-Monade
\end{lstlisting}

Außerdem wird die Funktion \lstinline|en_str| mehrfach verwendet.
Diese Funktion hat die Signatur \lstinline|String => Enumerator[E]| und macht aus einem übergebenen String einen \lstinline|Enumerator|, der als Elemente die einzelnen Zeichen des Strings generiert.
Die in den Code-Ausschnitten gezeigten Variablen \lstinline|left| und \lstinline|right| haben immer die gleiche Bedeutung.

\begin{enumerate}
  \item Komposition

    Die Komposition von \lstinline|Enumerator|s entspricht der Verkettung ihrer Eingaben.
    \lstinline|s1| und \lstinline|s2| in Listing~\ref{lst:kompositionsregel} sind zwei beliebige \lstinline|String|s.

    \begin{lstlisting}[caption=Kompositionsregel, label=lst:kompositionsregel]
val left: Enumerator[E] = en_str(s1 + s2)
val right: Enumerator[E] = en_str(s1).andThen(en_str(s2))
    \end{lstlisting}

  \item Verkettung

    Ein \lstinline|Iteratee| \lstinline|i|, der einen \lstinline|String| \lstinline|s1| erkennt, erkennt auch \lstinline|s1 + s2|, für jeden String \lstinline|s2|.
    Erkennen bedeutet, dass ein \lstinline|Iteratee| erfolgreich in den Endzustand \lstinline|Done| übergeht.

    \begin{lstlisting}[caption={Verkettungsregel, wenn ein Iteratee die Eingabe erkennt}, label=lst:verkettungsregel1]
def flatMap[A, B](m: IM[A], f: A => IM[B]): IM[B] =
  m.map(_.flatMapM(f))

val left: IM[String] = en_str(s1 + s2)(i.flatMap(f))
val right: IM[String] =
  flatMap(en_str(s1)(i), (x: String) => en_str(s2)(f(x)))
    \end{lstlisting}

    Die in Listing~\ref{lst:verkettungsregel1} verwendete Funktion \lstinline|flatMap| verhält sich wie auch andere \lstinline|flatMap|-Methoden.
    Diese Implementierung arbeitet allerdigns auf der Monade \lstinline|IM|, die aus \lstinline|Future| und \lstinline|Iteratee| zusammengesetzt ist.
    Erkennt der \lstinline|Iteratee| \lstinline|s1| nicht, so gilt die in Listing~\ref{lst:verkettungsregel2} abgebildete Gleichheit.

    \begin{lstlisting}[caption={Verkettungsregel, wenn ein Iteratee die Eingabe nicht erkennt}, label=lst:verkettungsregel2]
val left: IM[String] = en_str(s)(i.flatMap(f))
val right: IM[String] = en_str(s)(i).map(_.flatMap(f))
    \end{lstlisting}

  \item Nullelement

    Ein abweichender \lstinline|Iteratee| ist ein absorbierendes Element bzgl. \lstinline|flatMap|.
    Ein abweichender \lstinline|Iteratee| ist ein \lstinline|Iteratee|, der nach Empfang von \lstinline|Input.EOF| nicht in einen Endzustand übergeht.
    \lstinline|failure| in Listing~\ref{lst:nullelementregel} ist ein solcher \lstinline|Iteratee|.
    Ein absorbierendes Element ist ein Element, das, mit jedem anderen Element verknüpft, wieder das absorbierende Element ergibt \cite[vgl.][S.~15]{absorbing_element}.
    Die Null beispielsweise, ist das absorbierende Element der Multiplikation.

    \begin{lstlisting}[caption=Nullelementregel, label=lst:nullelementregel]
def failure[A]: I[A] = Cont(_ => failure)

val left: I[String] = failure.flatMap(f)
val right: I[String] = failure
    \end{lstlisting}

  \item Rechtsdistributivität

    \lstinline|flatMap| ist rechtsdistributiv, sofern der \lstinline|Iteratee| idempotent ist.
    Eine Funktion $f$ ist idempotent, wenn $f(x) = f(f(x))$ \cite[vgl.][S.~1]{idempotence}, mehr dazu im nächsten Absatz.

    \begin{lstlisting}[caption=Rechtsdistributivitätsregel, label=lst:rechtsdistributivitaetsregel]
val left: I[String] =
  i.flatMap(x => alternative(k1(x), k2(x)))
val right: I[String] =
  alternative(i.flatMap(k1), i.flatMap(k2))
    \end{lstlisting}

    \lstinline|alternative| komponiert die Ergebnis-\lstinline|Iteratee|s der beiden Funktionen \lstinline|k1| und \lstinline|k2|.
    Der resultierende \lstinline|Iteratee| erkennt, was der am schnellsten erkennende Eingabe-\lstinline|Iteratee| erkennt.
    Idempotenz wird von Kiselyov, wie in Listing~\ref{lst:idempotenz_eines_iteratees} zu sehen, definiert.

    \begin{lstlisting}[caption=Idempotenz eines Iteratees, label=lst:idempotenz_eines_iteratees]
val left: M[(I[A], I[A])] =
  en_str(s)(i).flatMap(x => Future((x, x)))
val right: M[(I[A], I[A])] =
  en_str(s)(i).flatMap(x =>
    en_str(s)(i).flatMap(y => Future((x, y))))
    \end{lstlisting}
\end{enumerate}

% subsection iteratee_gesetze (end)


% section streams (end)


% chapter reaktive_programmierung (end)