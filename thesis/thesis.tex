\documentclass[draft=false
              ,paper=a4
              ,twoside=false
              ,fontsize=11pt
              ,headsepline
              ,BCOR10mm
              ,DIV11
              ]{scrbook}
\usepackage[ngerman,english]{babel}
%% see http://www.tex.ac.uk/cgi-bin/texfaq2html?label=uselmfonts
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
% \usepackage[latin1]{inputenc}
\usepackage{libertine}
\usepackage{pifont}
\usepackage{microtype}
\usepackage{textcomp}
\usepackage[german,refpage]{nomencl}
\usepackage{setspace}
\usepackage{makeidx}
\usepackage{listings}
\usepackage{natbib}
\usepackage[ngerman,colorlinks=true]{hyperref}
\usepackage{soul}
\usepackage{hawstyle}
\usepackage{lipsum} %% for sample text
\usepackage{scrhack} %% remove warning http://tex.stackexchange.com/questions/51867/koma-warning-about-toc
\usepackage{todonotes}

\bibpunct[, ]{(}{)}{,}{a}{}{;} % correct citation format (no comma before year)

\setcounter{secnumdepth}{5} % numbering for subsubsections
\setcounter{tocdepth}{5} % show subsubsection in table of contents


%% define some colors
\colorlet{BackgroundColor}{gray!20}
\colorlet{KeywordColor}{blue}
\colorlet{CommentColor}{black!60}
%% for tables
\colorlet{HeadColor}{gray!60}
\colorlet{Color1}{blue!10}
\colorlet{Color2}{white}

%% configure colors
\HAWifprinter{
  \colorlet{BackgroundColor}{gray!20}
  \colorlet{KeywordColor}{black}
  \colorlet{CommentColor}{gray}
  % for tables
  \colorlet{HeadColor}{gray!60}
  \colorlet{Color1}{gray!40}
  \colorlet{Color2}{white}
}{}
\lstset{%
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{KeywordColor}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{CommentColor},
  backgroundcolor=\color{BackgroundColor},
  captionpos=b,
  fontadjust=true
}
\lstset{escapeinside={(*@}{@*)}, % used to enter latex code inside listings
        morekeywords={uint32_t, int32_t}
}
\ifpdfoutput{
  \hypersetup{bookmarksopen=false,bookmarksnumbered,linktocpage}
}{}

% "define" Scala http://tex.stackexchange.com/questions/47175/scala-support-in-listings-package
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

%% more fancy C++
\DeclareRobustCommand{\cxx}{C\raisebox{0.25ex}{{\scriptsize +\kern-0.25ex +}}}

\clubpenalty=10000
\widowpenalty=10000
\displaywidowpenalty=10000

% unknown hyphenations
\hyphenation{
}

%% recalculate text area
\typearea[current]{last}

\makeindex
\makenomenclature

\begin{document}
\selectlanguage{ngerman}
\lstset{language=Scala}

%%%%%
%% customize (see readme.pdf for supported values)
\HAWThesisProperties{Author={Till Theis}
                    ,Title={Das Play-Framework und dessen Einsatz zur Entwicklung von Real-Time-Web-Anwendungen}
                    ,EnglishTitle={The Play Framework and its Use for Developing Real-Time Web Applications}
                    ,ThesisType={Bachelorarbeit}
                    ,ExaminationType={Bachelorprüfung}
                    ,DegreeProgramme={Bachelor of Science Angewandte Informatik}
                    ,ThesisExperts={Prof.
Dr.
Friedrich Esser \and Prof.
Dr.
Zweitprüfer}
                    ,ReleaseDate={1.
Januar 2345}
                  }

%% title
\frontmatter

%% output title page
\maketitle

\onehalfspacing

%% add abstract pages
%% note: this is one command on multiple lines
\HAWAbstractPage
%% German abstract
{Schlüsselwort 1, Schlüsselwort 2}%
{Dieses Dokument \ldots}
%% English abstract
{keyword 1, keyword 2}%
{This document \ldots}

\newpage
\singlespacing

\tableofcontents
\newpage
%% enable if these lists should be shown on their own page
%%\listoftables
%%\listoffigures
\lstlistoflistings

%% main
\mainmatter
\onehalfspacing
%% write to the log/stdout
\typeout{===== File: chapter 1}
%% include chapter file (chapter1.tex)
%%\include{chapter1}

%%%%


\chapter{Einleitung} % (fold)
\label{cha:einleitung}

In Diesem Kapitel wird erläutert, was das Real-Time-Web ausmacht und weshalb sich das Play-Framework besonders eignet, Anwendungen dafür zu schreiben.
Es wird ein Überblick über die bisherige Entwicklung des Webs gegeben und klargestellt, womit sich diese Arbeit genau beschäftigt und womit nicht.
Anschließend wird aufgelistet, wie die weitere Struktur dieser Arbeit aussieht.


\section{Entwicklung des Webs} % (fold)
\label{sec:entwicklung_des_webs}

Nach \citealt{tavalsaari2011}~(S.~1--3) war das World Wide Web der 1990er Jahre ein Medium, bei dem einzelne Dokumente im Vordergrund standen.
Das klassische Web der ersten Hälfte des Jahrzehnts bestand aus Dokumenten mit Text, Bildern und Links.
Die zweite Hälfte machte das hybrid Web aus.
Browsertechnologien, wie Javascript und CSS, sowie Plugins wie Flash und QuickTime wurden entwickelt und erweiterten die statischen Dokumente um interaktive Elemente.

In den 2000ern verbreitete sich das dynamische Senden und Anfordern von Daten unter dem Namen Ajax (Asynchronous JavaScript and XML).
Gegen Ende des Jahrzehnts wurden die vorhandenen Technologien genutzt, um ganze Anwendungen damit zu schreiben, wie z.~B. Facebook oder Twitter.

% section entwicklung_des_webs (end)


\section{Real-Time-Web} % (fold)
\label{sec:real-time-web}

Eine Real-Time-Web-Anwendung ist eine Web-Anwendung, die automatisch neue Daten an den Client sendet, sobald diese dem Server bekannt werden.
Dies unterscheidet sich vom klassischen Pull-Prinzip, in dem nur der Client per Anfrage eine neue Seite beim Server anfordern kann.
Bei Real-Time-Events ist es stattdessen notwendig, dass der Server mittels Push-Prinzip neue Informationen an den Client sendet \cite[vgl.][S.~1]{bozdag2007}.
Facebook beispielsweise zeigt neue Statusmeldungen von Freunden an, ohne dass manuell die Seite neu geladen werden muss.

% section real-time-web (end)


\section{Motivation} % (fold)
\label{sec:motivation}

Wenn man die in Kap.~\ref{sec:entwicklung_des_webs} beschriebene Entwicklung des Webs betrachtet, knüpft das Real-Time-Web genau daran an.
Der Nachrichtenverkehr verläuft nicht mehr nur vom Client zum Server, sondern auch in umgekehrter Richtung vom Server zum Client.
Das Play-Framework besitzt Werkzeuge, mit dieser Art der Kommunikation umzugehen~\cite[vgl.][S.~5]{drobi2012}.

% section motivation (end)


\section{Themenabgrenzung} % (fold)
\label{sec:themenabgrenzung}

Diese Arbeit beschäftigt sich in erster Linie mit der Architektur und den Grundlagen des Play-Frameworks und den Teilen, die zur Entwicklung von Real-Time-Web-Anwendungen benötigt werden.
Einige Themenbereiche, die dafür nicht elementar sind, wie z.~B. Datenbanken, werden nicht behandelt.
Des Weiteren wird vorausgesetzt, dass der Leser bereits mit den Grundtechnologien der Web-Entwicklung, wie HTML, CSS und Javascript vertraut ist.

% section themenabgrenzung (end)


\section{Ziel} % (fold)
\label{sec:ziel}

Das Ziel dieser Arbeit ist es, das Play-Framework in Scala zu analysieren und dessen Grundlagen zu erklären, um schließlich seine Werkzeuge zur Entwicklung von Real-Time-Web-Anwendungen zu erforschen.
Auf Basis dieser Erkenntnisse wird anschließend eine Beispielanwendung analysiert und eine eigene Anwendung geschrieben, die das Real-Time-Prinzip ausnutzt.

% section ziel (end)


% chapter einleitung (end)


\section{Struktur} % (fold)
\label{sec:struktur}

% section struktur (end)




\chapter{Grundlagen} % (fold)
\label{cha:grundlagen}

Grundlagen mit den bisherigen Quellen \citealt{hilton2013}.


\section{Vorbereitung} % (fold)
\label{sec:vorbereitung}

\subsection{Entwicklungsumgebung} % (fold)
\label{sub:entwicklungsumgebung}

Es kann entweder mit einem einfachen Texteditor entwickelt werden, oder auch mit einer IDE (Integrated development environment).

Beispiel Sublime Text 2.

Als IDE wird hier IntelliJ IDEA 12 Community Edition verwendet.
Nach dem Anlegen des Play-Projekts auf der Kommandozeile muss ein mal der Befehl \lstinline|play idea| ausgeführt werden.
Wenn man sich bereits in der Play-Eingabemaske befindet, muss man nur \lstinline|idea| ausführen.
Eine umfangreiche Liste für weitere IDEs ist bei \citealt{ide}~\footnote{\url{http://www.playframework.com/documentation/2.1.1/IDE}} zu finden.

% subsection entwicklungsumgebung (end)

% section vorbereitung (end)


% chapter grundlagen (end)




\chapter{Reaktive Programmierung} % (fold)
\label{cha:reaktive_programmierung}

Reaktive Programmierung ist die Programmierung von reaktiven System.
Ein reaktives System ist ein System, das von seiner Umgebung kontinuierlich Daten empfängt und darauf reagiert.
In nebenläufigen Systemen können gleich mehrere solcher Datenströme unabhängig voneinander existieren \cite[vgl.][S.~1]{reactive_programming}.

Reaktive Prozesse haben die Eigenschaft, schrittweise, immer wenn sie neue Daten empfangen, ein Ergebnis aufzubauen.
Deshalb sind sie bei Berechnungen essentiell, bei denen nicht nur das Endergebnis wichtig ist, sondern auch die Schritte, die dazu geführt haben \cite[vgl.][S.~2]{reactive_programming1}.


\section{Futures und Promises} % (fold)
\label{sec:futures_und_promises}

Futures und Promises mit den Quellen \citealt{haller2013} und \citealt{typesafe2013}.

% section futures_und_promises (end)


\section{Streams} % (fold)
\label{sec:streams}

Streams sind inkrementelle Datenströme, die nicht-blockierendes Lesen erlauben und kombiniert und transformiert werden können.
Sie erlauben inkrementelle, deklarative und funktionale Datenverarbeitung mit voller Kontrolle über den Ressourcenverbrauch.
Anwendungsbeispiele für Streams sind beispielsweise die Implementierung von Web-Servern oder Datenkompression.
Die in diesem Kapitel vorgestellten Streams sind auch bekannt als Iteratee I/O.
Sie entstanden im Umfeld der Programmiersprache Haskell und wurden von Oleg Kiselyov vorgestellt \cite[vgl.][S.~19]{monad_reader}.
Als Quellen hierfür dienen \citealt{kiselyov2012}, \citealt{iteratee_io}, \citealt{monad_reader} und die Seiten der offiziellen Play-Dokumentation (\citealt{iteratees}, \cite{enumerators}).


\subsection{Design} % (fold)
\label{sub:design}

Iteratee IO-Streams bestehen aus vier Komponenten.
\lstinline|Input|, \lstinline|Iteratee|, \lstinline|Enumerator| und \lstinline|Enumeratee|.
\lstinline|Input| beinhaltet die gestreamten Elemente.
\lstinline|Iteratee| konsumiert \lstinline|Input|-Elemente und dient somit als Datensenke.
\lstinline|Enumerator| generiert \lstinline|Input|-Elemente und dient somit als Datenquelle.
Und \lstinline|Enumeratee| transformiert einen \lstinline|Iteratee|.
Diese Komponenten und ihr jeweiliger Verwendungszweck wird in diesem Kapitel vorgestellt.


\subsubsection{Inputs} % (fold)
\label{ssub:design_inputs}

Die von der Datenquelle generierten Elemente werden in \lstinline|Input|s verpackt.
Der Datentyp \lstinline|Input| ist definiert, wie in Listing~\ref{lst:der_input_datentyp} gezeigt.

\begin{lstlisting}[caption=Der \lstinline|Input|-Datentyp, label=lst:der_input_datentyp]
sealed trait Input[+E]
object Input {
  case class El[+E](e: E) extends Input[E]
  case object Empty extends Input[Nothing]
  case object EOF extends Input[Nothing]
}
\end{lstlisting}

Der Datentyp ist parametrisiert über den Typ der gehaltenen Elemente \lstinline|E|.

Für den Fall, dass die Datenquelle nicht erschöpft ist, existiert im Companion-Objekt die Unterklasse \lstinline|Input.El| mit dazugehöriger Konstruktorfunktion.
Diese Implementierung hält genau ein Element aus der Datenquelle.
\lstinline|Input.Empty| "`signifies a stream with no immediately available data but which is still continuing"' \cite[vgl.][]{iteratee_io}\todo{Ist Übernehmen von Kiselyovs Definition für Plays Implementierung erlaubt?}.
Außerdem findet es im Kontext von \lstinline|Iteratee|s Verwendung, um zu signalisieren, dass keine Eingabe übriggebliebenen ist.
Um zu signalisieren, dass die Datenquelle erschöpft ist, existiert das Objekt \lstinline|Input.EOF|.

Ein Wert vom Typ \lstinline|Input| hat also drei mögliche Zustände:
\begin{enumerate}
  \item Es gibt ein neues Element (\lstinline|Input.El|).
  \item Es gibt noch kein neues Element, doch die Datenquelle ist noch aktiv (\lstinline|Input.Empty|)
  \item Die Datenquelle ist erschöpft (\lstinline|Input.EOF|).
\end{enumerate}

% subsubsection design_inputs (end)


\subsubsection{Iteratees} % (fold)
\label{ssub:design_iteratees}

Die von der Datenquelle in \lstinline|Input|s verpackten Elemente werden von \lstinline|Iteratee|s konsumiert, um daraus ein Ergebnis aufzubauen.
\lstinline|Iteratee|s bilden einen Container um ihren Zustand \lstinline|Step|, der den Verarbeitungszustand widerspiegelt.
Der Typ des \lstinline|Step|-Zustands ist wie in Listing \ref{lst:der_step_datentyp} gezeigt.
\begin{lstlisting}[caption=Der \lstinline|Step|-Datentyp, label=lst:der_step_datentyp]
sealed trait Step[E, +A]
object Step {
  case class Done[+A, E](a: A, remaining: Input[E])
    extends Step[E, A]
  case class Cont[E, +A](k: Input[E] => Iteratee[E, A])
    extends Step[E, A]
  case class Error[E](msg: String, input: Input[E])
    extends Step[E, Nothing]
}
\end{lstlisting}

Der Typ ist über die zwei Typen \lstinline|E| und \lstinline|A| parametrisiert.
\lstinline|E| ist der Typ der zu konsumierenden Elemente.
\lstinline|A| ist der Typ des zu berechnenden Ergebnisses.

Ein \lstinline|Iteratee|, der mit seiner Berechnung fertig ist, ist im Zustand \lstinline|Step.Done|.
Ein solcher \lstinline|Iteratee| hält sein berechnetes Ergebnis und den Teil der letzten Eingabe, der nicht mehr verarbeitet wurde.
Ein \lstinline|Iteratee| in diesem Zustand nimmt keine weiteren Elemente an.
Häufig ist der Eingaberest \lstinline|Input.Empty|, weil die gesamte Eingabe konsumiert wurde.
Ein Beispiel für einen nicht leeren Eingaberest ist, wenn ein \lstinline|Iteratee| zeilenweise Dateiinhalte empfängt und darin nach einem Wort sucht.
Wenn das gesuchte Wort gefunden wurde, wird als Restwert der bisher nicht angesehene Rest der Zeile verwendet.

Ein \lstinline|Iteratee|, der noch kein Endergebnis berechnet hat, ist im Zustand \lstinline|Step.Cont|.
Das Argument von \lstinline|Step.Cont| ist die Schritt-Funktion \lstinline[breaklines=true]|Input[E] => Iteratee[E, A]|\todo{Continuation? Weil nicht genau nach Definition}.
Die Eingabe der Schritt-Funktion ist ein \lstinline|Input| mit einem neuen zu verarbeitenden Element.
Die Ausgabe der Schritt-Funktion ist ein neuer \lstinline|Iteratee|, der den neuen Berechnungsstand nach dem Verarbeiten des Eingabeelements hält.

Falls bei der Verarbeitung eines Elements ein Fehler auftritt, wird dies durch den Zustand \lstinline|Step.Error| signalisiert.
Ein solcher Fehler wird durch eine Fehlermeldung und durch das verursachende Eingabeelement dargestellt.
Beispielsweise kann ein \lstinline|Iteratee| nach dem Empfang eines \lstinline|Input.EOF|-Elements signalisieren, dass es noch mehr Daten benötigt.
%In diesem Fall kann das System versuchen doch noch mehr Daten zu finden, sodass der \lstinline|Iteratee| erfolgreich zu einem Ergebnis kommen kann.

Ein \lstinline|Iteratee| hat also einen Verarbeitungszustand vom Typ \lstinline|Step| mit drei möglichen Zuständen:
\begin{enumerate}
  \item Es wurde erfolgreich ein Ergebnis berechnet (\lstinline|Step.Done|).
  \item Es werden weitere Daten zur Berechnung benötigt (\lstinline|Step.Cont|).
  \item Es ist ein Fehler aufgetreten (\lstinline|Step.Error|).
\end{enumerate}

Außerdem ist anzumerken, dass der \lstinline|Iteratee|-Typ ist eine Monade.
Dadurch ist es möglich, einen beliebigen Wert in die Monade zu heben, die dann im \lstinline|Step.Done|-Zustand ist.
Auch kann ein erfolgreich berechneter Wert innerhalb der Monade transformiert werden.

% subsubsection design_iteratees (end)


\subsubsection{Enumerators} % (fold)
\label{ssub:design_enumerators}

Ein \lstinline|Enumerator| ist die Datenquelle, die ihre Daten, in \lstinline|Input|s verpackt, bereitstellt.
Der Datentyp \lstinline|Enumerator| ist definiert, wie in Listing~\ref{lst:der_enumerator_datentyp} vereinfacht dargestellt.
\begin{lstlisting}[caption=Der \lstinline|Enumerator|-Datentyp, label=lst:der_enumerator_datentyp]
trait Enumerator[E] {
  def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]]
}
\end{lstlisting}

Ein \lstinline|Enumerator| ist eine Funktion von \lstinline|Iteratee| nach \lstinline|Iteratee| und ist über die Typen des übergebenen \lstinline|Iteratee|s parametrisiert.
Der Eingabewert ist der \lstinline|Iteratee|, an den die generierten Elemente gesendet werden.
Der Rückgabewert ist der übergebene \lstinline|Iteratee| nach Fertigstellung oder Abbruch seiner Berechnung.
Der zurückgegebene \lstinline|Iteratee| befindet sich in der \lstinline|Future|-Monade.

Bei der Anwendung dieser Funktion werden dem \lstinline|Iteratee| so lange Daten übergeben, bis die Datenquelle erschöpft ist, oder bis der \lstinline|Iteratee| keine Daten mehr annimmt.
Die Herkunft der Daten, die der \lstinline|Enumerator| an den \lstinline|Iteratee| sendet, ist beliebig.
Weil der Rückgabetyp sich in der \lstinline|Future|-Monade befindet können auch zeitintensive Berechnungen durchgeführt werden, ohne den Programmfluss zu unterbrechen.
Dadurch ist es beispielsweise möglich, die Daten aus Dateien oder dem Netzwerk zu empfangen.

% subsubsection design_enumerators (end)


\subsubsection{Enumeratees} % (fold)
\label{ssub:design_enumeratees}

Ein \lstinline|Enumeratee| ist ein Stream-Transformator, der \lstinline|Iteratee|s eines bestimmten Element-Typs zu \lstinline|Iteratee|s eines anderen Element-Typs konvertiert.
Der Datentyp \lstinline|Enumeratee| ist definiert, wie in Listing~\ref{lst:der_enumeratee_datentyp} vereinfacht dargestellt.
\begin{lstlisting}[caption=Der \lstinline|Enumeratee|-Datentyp, label=lst:der_enumeratee_datentyp]
trait Enumeratee[From, To] {
  def apply[A](inner: Iteratee[To, A]):
    Iteratee[From, Iteratee[To, A]]
}
\end{lstlisting}

Ein \lstinline|Enumeratee| ist eine Funktion von \lstinline|Iteratee| nach \lstinline|Iteratee|.
Der Eingabewert ist der zu transformierende \lstinline|Iteratee| vom inneren Element-Typ \lstinline|To|.
Der Ausgabewert ist ein \lstinline|Iteratee| vom "a"seren Element-Typ \lstinline|From|.
Der neue \lstinline|Iteratee| nimmt Elemente vom Typ \lstinline|From| an und transformiert sie nach \lstinline|To|.
Diese transformierten Werte werden dann an den ursprünglichen \lstinline|Iteratee| weitergegeben.

Elemente vom Typ \lstinline|From| hei"sen "a"sere Elemente, weil sie vom resultierenden \lstinline|Iteratee| zuerst empfangen werden.
Elemente vom Typ \lstinline|To| hei"sen innere Elemente, weil sie zum \lstinline|Iteratee| geh"oren, das sich im R"uckgabetyp des resultierenden \lstinline|Iteratee|s befindet.
Die Elemente des "au"seren \lstinline|Iteratees| werden nach der Transformation an den inneren \lstinline|Iteratee| weitergereicht.

Die Transformation muss dabei aber nicht ein Element nach genau einem anderen Element abbilden.
Ein äußeres Element \lstinline|From| kann zu einem, keinem oder auch mehreren inneren Elementen \lstinline|To| abgebildet werden.
Genauso ist es möglich, dass mehrere äußere Elemente zu einem inneren Element zusammengefasst werden.

Jeder \lstinline|Enumeratee| ist eigentlich auch ein \lstinline|Enumerator|.
Dies kommt daher, dass \lstinline|Iteratee|s Monaden sind.
Ein \lstinline|Enumeratee| ist ein \lstinline|Enumerator|, dessen Ergebnis nicht in der \lstinline|Future|-Monade, sondern in der \lstinline|Iteratee|-Monade liegt.
Jeder \lstinline|Enumeratee| ist auch ein \lstinline|Iteratee|, wenn man seinen Rückgabewert betrachtet, der vom Typ \lstinline|Iteratee| ist.
Ein \lstinline|Enumeratee| ist also sowohl in der Rolle eines \lstinline|Iteratee|s, als auch in der Rolle eines \lstinline|Enumerator|s.
Er ist ein \lstinline|Iteratee| des äußeren Typs \lstinline|From| und ein \lstinline|Enumerator| des inneren Typs \lstinline|To|, weil er Elemente des "au"seren Typs konsumiert und Elemente des inneren Typs generiert.

% subsubsection design_enumeratees (end)


\subsubsection{Komposition} % (fold)
\label{ssub:komposition}

\lstinline|Iteratee|s und \lstinline|Enumerator|s können sequentiell, parallel oder auch frei komponiert werden.
Bei der Komposition werden zwei oder mehr \lstinline|Iteratee|s oder \lstinline|Enumerator|s zu einem neuen \lstinline|Iteratee| oder \lstinline|Enumerator| kombiniert.

\paragraph{Komposition von Iteratees} % (fold)
\label{par:komposition_von_iteratees}\mbox{} % force new line

Sequenzielle Komposition zweier \lstinline|Iteratee|s funktioniert noch folgendem Prinzip:
Zuerst wird der erste \lstinline|Iteratee| angewendet, bis er keine Elemente mehr annimmt, oder die Datenquelle erschöpft ist.
Dann wird der zweite \lstinline|Iteratee| auf die noch übrigen Elemente der Datenquelle angewendet, bis auch dieser \lstinline|Iteratee| keine Elemente mehr annimmt, oder die Datenquelle erschöpft ist.
Anschließend werden beide \lstinline|Iteratee|s kombiniert.
Z.~B. als Paar. % Iteratee#map/flatMap

Bei der parallelen Komposition werden die Elemente der Datenquelle immer an beide \lstinline|Iteratee|s weitergegeben.
Dies geschieht so lange, bis beide \lstinline|Iteratee|s keine weiteren Elemente mehr annehmen.
Anschließend werden beide \lstinline|Iteratee|s kombiniert. % Enumeratee.zip/zipWith

\lstinline|Iteratee|s könnnen auch frei kombiniert werden, sodass z.~B. nur bestimmte Elemente an den einen \lstinline|Iteratee| delegiert werden und alle anderen Elemente an den anderen \lstinline|Iteratee| delegiert werden.

% paragraph komposition_von_iteratees (end)

\paragraph{Komposition von Enumerators} % (fold)
\label{par:komposition_von_enumerators}\mbox{} % force new line

Die sequentielle Komposition zweier \lstinline|Enumerator|s erfolgt ähnlich, wie die sequentielle Kompositionen von \lstinline|Iteratee|s.
Der resultierende \lstinline|Enumerator| generiert erst alle Elemente des ersten \lstinline|Enumerator|s und dann alle Elemente des zweiten \lstinline|Enumerator|s.
Die sequentielle Komposition von \lstinline|Enumerator|s entspricht also der Verkettung ihrer Ausgaben. %Enumerator.andThen

Parallele Komposition von \lstinline|Enumerator|s bedeutet, dass jedes Element des kombinierten \lstinline|Enumerator|s entweder aus dem ersten, oder aus dem zweiten \lstinline|Enumerator| stammt.
Die Reihenfolge der Elemente ist dadurch bestimmt, welcher \lstinline|Enumerator| zuerst ein neues Element zur Verfügung stellt. % Enumerator.interleave

\lstinline|Enumerator|s können auch frei kombiniert werden, wobei beliebig gewählt werden kann, aus welchem der zur Verfügung stehenden \lstinline|Enumerator|s gelesen wird.
Dabei ist es durchaus denkbar, dass Elemente mehrerer \lstinline|Enumerator|s zu einem Element kombiniert werden.
Auch ist es möglich, dass in Abhängigkeit der generierten Elemente eines \lstinline|Enumerator|s, ein anderer \lstinline|Enumerator| für das nächste Element ausgesucht wird.
Beispielsweise kann solange aus dem einen \lstinline|Enumerator| gelesen werden, bis ein bestimmtes Element auftritt.
Dann wird der andere \lstinline|Enumerator| ausgewählt, aus dem die folgenden Elemente extrahiert werden.

% paragraph komposition_von_enumerators (end)

% subsubsection komposition (end)


% subsection design (end)


\subsection{Anwendung} % (fold)
\label{sub:anwendung}

Im vorigen Kapitel wurden die einzelnen Komponenten vorgestellt.
In diesem Kapitel soll der ihr Einsatz mit Hilfe von konkreten Code-Beispielen gezeigt werden.


\subsubsection{Iteratees} % (fold)
\label{sssec:iteratees}

\paragraph{Grundlagen} % (fold)
\label{par:grundlagen}\mbox{} % force new line

Plays \lstinline|Iteratee|s bilden einen Container für ihren \lstinline|Step|-Zustand.
Dadurch werden, wie bei objektorientierten Sprachen üblich\todo{Zitat}, Daten und Operationen gebündelt.
Die elementare Methode dieser Klasse ist \lstinline|fold|.
Die Signatur dazu ist in Listing~\ref{lst:fold_signatur} zu lesen.
\begin{lstlisting}[caption=Die Signatur von \lstinline|fold|, label=lst:fold_signatur]
def fold[B](folder: Step[E, A] => Future[B]): Future[B]
\end{lstlisting}

Mit Hilfe von \lstinline|fold| lässt sich der Zustand des \lstinline|Iteratee|s transformieren.
Deshalb sind sehr viele Methoden in der \lstinline|Iteratee|-Klasse auf Basis von \lstinline|fold| definiert.
Durch Angabe der Schrittfunktion im \lstinline|Cont|-Konstruktor bestimmt die konkrete \lstinline|Iteratee|-Implementierung, wie mit übergebenen Elementen umzugehen ist.
Nur durch diese Funktion können neue Elemente gelesen werden.
Dadurch wird der zu berechnende Wert aufgebaut.

% paragraph grundlagen (end)

\paragraph{Iteratees erstellen} % (fold)
\label{par:iteratees_erstellen}\mbox{} % force new line

Es gibt drei Möglichkeiten, einen neuen \lstinline|Iteratee| zu erstellen.
\begin{enumerate}
  \item Durch Erstellung einer neuen Klasse, die von \lstinline|Iteratee| erbt und \lstinline|fold| implementiert.
  \item Durch Benutzung einer Konstruktorfunktion analog zu den \lstinline|Step|-Zuständen (\lstinline|Done|, \lstinline|Cont| und \lstinline|Error|).
  \item Durch Benutzung einer Hilfsfunktion des Companion-Objekts (\lstinline|fold|, \lstinline|foreach|, u.~a.).
\end{enumerate}

Zu Demonstrationszwecken soll nun ein \lstinline|Iteratee| erstellt werden, der alle Elemente aufsummiert.
Es wird dabei nach jeder der drei möglichen Varianten implementiert.

\subparagraph{Erstellung durch Vererbung} % (fold)
\label{subp:erstellung_durch_vererbung}\mbox{} % force new line

Die erste Variante ist, von \lstinline|Iteratee| zu erben und die \lstinline|fold|-Methode zu implementieren.
Dies erfordert viel Schreibarbeit, weil nur die sehr generische \lstinline|fold|-Methode verwendet werden kann.
Der Code dazu ist in Listing~\ref{lst:iteratee_durch_vererbung} zu sehen.

\begin{lstlisting}[caption=Erstellung eines \lstinline|Iteratee|s durch Vererbung, label=lst:iteratee_durch_vererbung]
case class SumIteratee(sum: Int = 0) extends Iteratee[Int, Int] {
  def fold[B](folder: Step[Int, Int] => Future[B]): Future[B] = {
    folder(Step.Cont(_ match {
      case Input.El(i) => SumIteratee(sum + i)
      case Input.Empty => this
      case Input.EOF   => new Iteratee[Int, Int] {
        def fold[B](folder: Step[Int, Int] => Future[B]) = {
          folder(Step.Done(sum, Input.EOF))
        }
      }
    }))
  }
}

val sumIterateeFromInheritance: Iteratee[Int, Int] = SumIteratee()
\end{lstlisting}

Der \lstinline|folder|-Funktion muss der aktuelle \lstinline|Step|-Zustand übergeben werden.
Diese Funktion soll den \lstinline|Iteratee| dann ausführen, d.~h. ihn mit Elementen versorgen.
Anschließend soll der \lstinline|folder| dann aus dem finalen Zustand ein Ergebnis berechnen.
Solange noch weitere Elemente kommen können, also solange kein \lstinline|Input.EOF|-Element empfangen wurde, geht der \lstinline|Iteratee| in einen neuen \lstinline|Cont|-Zustand über.
Bei diesem Zustandsübergang wird auch die interne Berechnung fortgesetzt.
Es wird also in einen \lstinline|Cont|-Zustand übergegangen, der die aktualisierte Summe hält.
Wenn ein leeres Element (\lstinline|Input.Empty|) verarbeitet werden soll, wird der \lstinline|Iteratee| unverändert zurückgegeben, weil sich an der Gesamtsumme nichts geändert hat.
Sobald keine weiteren Elemente mehr kommen können, wird die Berechnung beendet und ein \lstinline|Iteratee| an den \lstinline|folder| übergeben, der sich immer im \lstinline|Done|-Zustand befindet.

% subparagraph erstellung_durch_vererbung (end)

\subparagraph{Erstellung durch Konstruktorfunktion} % (fold)
\label{subp:erstellung_durch_konstruktorfunktion}\mbox{} % force new line

Die zweite Möglichkeit, einen \lstinline|Iteratee| zu erstellen, ist mit Hilfe einer der Konstruktorfunktionen.
Es gibt die Konstruktorfunktionen \lstinline|Done|, \lstinline|Cont| und \lstinline|Error|, die jeweils einen \lstinline|Iteratee| im gleichnamigen \lstinline|Step|-Zustand erstellen.
Der Code, der einen \lstinline|Iteratee| mit Hilfe dieser Funktionen erstellt, ist in Listing~\ref{lst:iteratee_durch_konstruktorfunktion} zu sehen.

\begin{lstlisting}[caption=Erstellung eines \lstinline|Iteratee|s durch eine Konstruktorfunktion, label=lst:iteratee_durch_konstruktorfunktion]
def sumIteratee(sum: Int = 0): Iteratee[Int, Int] = Cont(_ match {
  case Input.El(i) => sumIteratee(sum + i)
  case Input.Empty => sumIteratee(sum)
  case Input.EOF   => Done(sum, Input.EOF)
})

val sumIterateeFromConstructor: Iteratee[Int, Int] = sumIteratee()
\end{lstlisting}

Der Code ist dem in \nameref{subp:erstellung_durch_vererbung} vorgestellten Code sehr ähnlich.
Im Gegensatz dazu muss hier jedoch nicht mehr explizit von \lstinline|Iteratee| geerbt und die \lstinline|fold|-Methode implementiert werden.
Dies macht den Code schon wesentlich kürzer und einfacher.
Der Code ist auf die elementaren Aufgaben reduziert und es ist nun klar zu erkennen, was bei welcher Eingabe geschieht.

% subparagraph erstellung_durch_konstruktorfunktion (end)

\subparagraph{Erstellung durch Hilfsmethode} % (fold)
\label{subp:erstellung_durch_hilfsmethode}\mbox{} % force new line

Die dritte und letzte Möglichkeit nutzt eine problemspezifische Hilfsmethode.
Das Aufsummieren von Menge von Zahlen lässt sich sehr einfach mit Hilfe eines Folds implementieren\todo{Erklären, was ein Fold ist}.
Das \lstinline|Iteratee|-Companion-Objekt beinhaltet u.~a. die \lstinline|fold|-Hilfsmethode, die für solche Operationen gedacht ist.
Durch Einsatz dieser Methode wird die Lösung, wie in Listing~\ref{lst:iteratee_durch_hilfsmethode} zu erkennen, zum Einzeiler.

\begin{lstlisting}[caption=Erstellung eines \lstinline|Iteratee|s durch eine Hilfsmethode, label=lst:iteratee_durch_hilfsmethode]
val sumIterateeFromHelper: Iteratee[Int, Int] =
  Iteratee.fold(0)(_ + _)
\end{lstlisting}

Vom Filtern der unterschiedlichen \lstinline|Input|-Typen ist hierbei abstrahiert und es muss sich nur noch um tatsächliche Eingabeelemente gekümmert werden.

% subparagraph erstellung_durch_hilfsmethode (end)

% paragraph iteratees_erstellen (end)

\paragraph{Iteratees ausführen} % (fold)
\label{par:iteratees_ausfuehren}\mbox{} % force new line

Um die \lstinline|Iteratee|s mit Daten zu versorgen, existiert, wie in \nameref{par:iteratees_erstellen} beschrieben, die Methode \lstinline|fold|.
\lstinline|fold| nimmt als Argument eine Funktion \lstinline|folder| vom Typ \lstinline|Step[E, A] => Future[B]|.
Diese Funktion übergibt ein Element an den \lstinline|Iteratee| und muss daraufhin den Zustand des neuen \lstinline|Iteratee|s überprüfen, ob weitere Elemente akzeptiert werden, oder nicht nicht.
Erst nach dieser Analyse kann entschieden werden, ob ein weiteres Element übergeben wird oder nicht.
Das übergeben von Daten mittels der \lstinline|fold|-Methode ist, wie in Listing~\ref{lst:iterateeausfuehrung_durch_folder} zu erkennen, recht aufwändig.

\begin{lstlisting}[caption=Ausführung eines \lstinline|Iteratee|s durch \lstinline|folder|-Funktion, label=lst:iterateeausfuehrung_durch_folder]
def folder(xs: List[Int])(step: Step[Int, Int]): Future[Int] =
  xs match {
    case Nil => step match {
      case Step.Cont(k) => k(Input.EOF).fold(_ match {
        case Step.Done(sum, Input.EOF) => Future(sum)
        case _ => throw new Exception("invalid state")
      })
      case _ => throw new Exception("invalid state")
    }
    case x :: xs => step match {
      case Step.Cont(k) => k(Input.El(x)).fold(folder(xs))
      case _ => throw new Exception("invalid state")
    }
  }

val sumResult: Future[Int] =
  sumIterateeFromHelper.fold(folder(List(1, 4, -2)))
\end{lstlisting}

Durch Verwendung von \lstinline|Enumerator|s wird dies allerdings wesentlich einfacher.

% paragraph iteratees_ausfuehren (end)

% subsubsection iteratees (end)

\subsubsection{Enumerators} % (fold)
\label{ssub:enumerators}

Mit Hilfe von \lstinline|Enumerator|s können auf einfache Weise Daten an einen \lstinline|Iteratee| übergeben werden.
Das Ergebnis der Anwendung eines \lstinline|Enumerator|s ist der \lstinline|Iteratee| nach Konsum der Elemente in der \lstinline|Future|-Monade.

% subsubsection enumerators (end)


\subsubsection{Regeln} % (fold)
\label{ssub:regeln}

Die folgenden Regeln sind \citealt{kiselyov2012}~(S.~12--13) entnommen und dienen derzeit nur zum Verständnis des Autors.
Sie werden später, sofern möglich, an geeigneter Stelle einsortiert.

\lstinline!k |> l! ist der Alternativ-Kombinator. Der Iteratee, der als erstes ein Ergebnis liefert, wird zurückgegeben.

\begin{enumerate}
  \item Komposition
    \begin{lstlisting}
enstr (s1 ++ s2) = enstr s2 . enstr s1
    \end{lstlisting}

    Eingaben konkatenieren ist das gleiche, wie Enumeratoren zu konkatenieren.

  \item Verkettung
    \begin{lstlisting}
enstr (s1 ++ s2)(i >>= f) = enstr s1 i >>= enstr s2 . f
    \end{lstlisting}

    Wenn Iteratee i s1 erkennt, dann ist das Verarbeiten und Verwerten der der konkatenierten Eingaben das gleiche, wie das Verarbeiten und Verwerten der ersten Eingabe und anschließend das Verarbeiten der zweiten Eingabe.

  \item Neutrales Element
    \begin{lstlisting}
failure >>= f = failure
    \end{lstlisting}

    Wenn ein Iteratee einen Fehler erzeugt, haben auch folgende Iteratees keine Chance mehr auf Erfolg.

  \item Rechtsdistributivität
    \begin{lstlisting}
i >>= \x -> (k1 x |> k2 x) = (i >>= k1) |> (i >>= k2)
    \end{lstlisting}

    Iteratees sind rechtsdistributiv, d.h. erst Iteratee i auszuführen und auf das Ergebnis k1 oder k2 auszuführen ist das gleiche, als i und darauf k1 auszuführen oder i und darauf k2 auszuführen.
\end{enumerate}

% subsubsection regeln (end)

% subsection anwendung (end)


% section streams (end)


% section serverseitig (end)

% chapter reaktive_programmierung (end)




\chapter{Schluss} % (fold)
\label{cha:schluss}

% chapter schluss (end)


%%%%

%% appendix if used
%%\appendix
%%\typeout{===== File: appendix}
%%\include{appendix}

% bibliography and other stuff
\backmatter

\typeout{===== Section: literature}
%% read the documentation for customizing the style
\bibliographystyle{dinat}
\bibliography{thesis}

\typeout{===== Section: nomenclature}
%% uncomment if a TOC entry is needed
%%\addcontentsline{toc}{chapter}{Glossar}
\renewcommand{\nomname}{Glossar}
\clearpage
\markboth{\nomname}{\nomname} %% see nomencl doc, page 9, section 4.1
\printnomenclature

%% index
\typeout{===== Section: index}
\printindex

\HAWasurency

\end{document}
