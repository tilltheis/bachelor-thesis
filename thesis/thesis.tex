\documentclass[draft=false
              ,paper=a4
              ,twoside=false
              ,fontsize=11pt
              ,headsepline
              ,BCOR10mm
              ,DIV11
              ]{scrbook}
\usepackage[ngerman,english]{babel}
%% see http://www.tex.ac.uk/cgi-bin/texfaq2html?label=uselmfonts
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
% \usepackage[latin1]{inputenc}
\usepackage{libertine}
\usepackage{pifont}
\usepackage{microtype}
\usepackage{textcomp}
\usepackage[german,refpage]{nomencl}
\usepackage{setspace}
\usepackage{makeidx}
\usepackage{listings}
\usepackage{natbib}
\usepackage[ngerman,colorlinks=true]{hyperref}
\usepackage{soul}
\usepackage{hawstyle}
\usepackage{lipsum} %% for sample text
\usepackage{scrhack} %% remove warning http://tex.stackexchange.com/questions/51867/koma-warning-about-toc

\bibpunct[, ]{(}{)}{,}{a}{}{;} % correct citation format (no comma before year)

\setcounter{secnumdepth}{5} % numbering for subsubsections
\setcounter{tocdepth}{5} % show subsubsection in table of contents


%% define some colors
\colorlet{BackgroundColor}{gray!20}
\colorlet{KeywordColor}{blue}
\colorlet{CommentColor}{black!60}
%% for tables
\colorlet{HeadColor}{gray!60}
\colorlet{Color1}{blue!10}
\colorlet{Color2}{white}

%% configure colors
\HAWifprinter{
  \colorlet{BackgroundColor}{gray!20}
  \colorlet{KeywordColor}{black}
  \colorlet{CommentColor}{gray}
  % for tables
  \colorlet{HeadColor}{gray!60}
  \colorlet{Color1}{gray!40}
  \colorlet{Color2}{white}
}{}
\lstset{%
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{KeywordColor}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{CommentColor},
  backgroundcolor=\color{BackgroundColor},
  captionpos=b,
  fontadjust=true
}
\lstset{escapeinside={(*@}{@*)}, % used to enter latex code inside listings
        morekeywords={uint32_t, int32_t}
}
\ifpdfoutput{
  \hypersetup{bookmarksopen=false,bookmarksnumbered,linktocpage}
}{}

% "define" Scala http://tex.stackexchange.com/questions/47175/scala-support-in-listings-package
\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

%% more fancy C++
\DeclareRobustCommand{\cxx}{C\raisebox{0.25ex}{{\scriptsize +\kern-0.25ex +}}}

\clubpenalty=10000
\widowpenalty=10000
\displaywidowpenalty=10000

% unknown hyphenations
\hyphenation{
}

%% recalculate text area
\typearea[current]{last}

\makeindex
\makenomenclature

\begin{document}
\selectlanguage{ngerman}
\lstset{language=Scala}

%%%%%
%% customize (see readme.pdf for supported values)
\HAWThesisProperties{Author={Till Theis}
                    ,Title={Das Play-Framework und dessen Einsatz zur Entwicklung von Real-Time-Web-Anwendungen}
                    ,EnglishTitle={The Play Framework and its Use for Developing Real-Time Web Applications}
                    ,ThesisType={Bachelorarbeit}
                    ,ExaminationType={Bachelorprüfung}
                    ,DegreeProgramme={Bachelor of Science Angewandte Informatik}
                    ,ThesisExperts={Prof.
Dr.
Friedrich Esser \and Prof.
Dr.
Zweitprüfer}
                    ,ReleaseDate={1.
Januar 2345}
                  }

%% title
\frontmatter

%% output title page
\maketitle

\onehalfspacing

%% add abstract pages
%% note: this is one command on multiple lines
\HAWAbstractPage
%% German abstract
{Schlüsselwort 1, Schlüsselwort 2}%
{Dieses Dokument \ldots}
%% English abstract
{keyword 1, keyword 2}%
{This document \ldots}

\newpage
\singlespacing

\tableofcontents
\newpage
%% enable if these lists should be shown on their own page
%%\listoftables
%%\listoffigures
\lstlistoflistings

%% main
\mainmatter
\onehalfspacing
%% write to the log/stdout
\typeout{===== File: chapter 1}
%% include chapter file (chapter1.tex)
%%\include{chapter1}

%%%%


\chapter{Einleitung} % (fold)
\label{cha:einleitung}

In Diesem Kapitel wird erläutert, was das Real-Time-Web ausmacht und weshalb sich das Play-Framework besonders eignet, Anwendungen dafür zu schreiben.
Es wird ein Überblick über die bisherige Entwicklung des Webs gegeben und klargestellt, womit sich diese Arbeit genau beschäftigt und womit nicht.
Anschließend wird aufgelistet, wie die weitere Struktur dieser Arbeit aussieht.


\section{Entwicklung des Webs} % (fold)
\label{sec:entwicklung_des_webs}

Nach \citealt{tavalsaari2011}~(S.~1--3) war das World Wide Web der 1990er Jahre ein Medium, bei dem einzelne Dokumente im Vordergrund standen.
Das klassische Web der ersten Hälfte des Jahrzehnts bestand aus Dokumenten mit Text, Bildern und Links.
Die zweite Hälfte machte das hybrid Web aus.
Browsertechnologien, wie Javascript und CSS, sowie Plugins wie Flash und QuickTime wurden entwickelt und erweiterten die statischen Dokumente um interaktive Elemente.

In den 2000ern verbreitete sich das dynamische Senden und Anfordern von Daten unter dem Namen Ajax (Asynchronous JavaScript and XML).
Gegen Ende des Jahrzehnts wurden die vorhandenen Technologien genutzt, um ganze Anwendungen damit zu schreiben, wie z.~B. Facebook oder Twitter.

% section entwicklung_des_webs (end)


\section{Real-Time-Web} % (fold)
\label{sec:real-time-web}

Eine Real-Time-Web-Anwendung ist eine Web-Anwendung, die automatisch neue Daten an den Client sendet, sobald diese dem Server bekannt werden.
Dies unterscheidet sich vom klassischen Pull-Prinzip, in dem nur der Client per Anfrage eine neue Seite beim Server anfordern kann.
Bei Real-Time-Events ist es stattdessen notwendig, dass der Server mittels Push-Prinzip neue Informationen an den Client sendet \cite[vgl.][S.~1]{bozdag2007}.
Facebook beispielsweise zeigt neue Statusmeldungen von Freunden an, ohne dass manuell die Seite neu geladen werden muss.

% section real-time-web (end)


\section{Motivation} % (fold)
\label{sec:motivation}

Wenn man die in Kap.~\ref{sec:entwicklung_des_webs} beschriebene Entwicklung des Webs betrachtet, knüpft das Real-Time-Web genau daran an.
Der Nachrichtenverkehr verläuft nicht mehr nur vom Client zum Server, sondern auch in umgekehrter Richtung vom Server zum Client.
Das Play-Framework besitzt Werkzeuge, mit dieser Art der Kommunikation umzugehen~\cite[vgl.][S.~5]{drobi2012}.

% section motivation (end)


\section{Themenabgrenzung} % (fold)
\label{sec:themenabgrenzung}

Diese Arbeit beschäftigt sich in erster Linie mit der Architektur und den Grundlagen des Play-Frameworks und den Teilen, die zur Entwicklung von Real-Time-Web-Anwendungen benötigt werden.
Einige Themenbereiche, die dafür nicht elementar sind, wie z.~B. Datenbanken, werden nicht behandelt.
Des Weiteren wird vorausgesetzt, dass der Leser bereits mit den Grundtechnologien der Web-Entwicklung, wie HTML, CSS und Javascript vertraut ist.

% section themenabgrenzung (end)


\section{Ziel} % (fold)
\label{sec:ziel}

Das Ziel dieser Arbeit ist es, das Play-Framework in Scala zu analysieren und dessen Grundlagen zu erklären, um schließlich seine Werkzeuge zur Entwicklung von Real-Time-Web-Anwendungen zu erforschen.
Auf Basis dieser Erkenntnisse wird anschließend eine Beispielanwendung analysiert und eine eigene Anwendung geschrieben, die das Real-Time-Prinzip ausnutzt.

% section ziel (end)


% chapter einleitung (end)


\section{Struktur} % (fold)
\label{sec:struktur}

% section struktur (end)




\chapter{Grundlagen} % (fold)
\label{cha:grundlagen}

Grundlagen mit den bisherigen Quellen \citealt{hilton2013}.


\section{Vorbereitung} % (fold)
\label{sec:vorbereitung}

\subsection{Entwicklungsumgebung} % (fold)
\label{sub:entwicklungsumgebung}

Es kann entweder mit einem einfachen Texteditor entwickelt werden, oder auch mit einer IDE (Integrated development environment).

Beispiel Sublime Text 2.

Als IDE wird hier IntelliJ IDEA 12 Community Edition verwendet.
Nach dem Anlegen des Play-Projekts auf der Kommandozeile muss ein mal der Befehl \lstinline|play idea| ausgeführt werden.
Wenn man sich bereits in der Play-Eingabemaske befindet, muss man nur \lstinline|idea| ausführen.
Eine umfangreiche Liste für weitere IDEs ist bei \citealt{ide}~\footnote{\url{http://www.playframework.com/documentation/2.1.1/IDE}} zu finden.

% subsection entwicklungsumgebung (end)

% section vorbereitung (end)


% chapter grundlagen (end)




\chapter{Reaktive Programmierung} % (fold)
\label{cha:reaktive_programmierung}

Reaktive Programmierung ist die Programmierung von reaktiven System.
Ein reaktives System ist ein System, das von seiner Umgebung kontinuierlich Daten empfängt und darauf reagiert.
In nebenläufigen Systemen können gleich mehrere solcher Datenströme unabhängig voneinander existieren \cite[vgl.][S.~1]{reactive_programming}.

Reaktive Prozesse haben die Eigenschaft, schrittweise, immer wenn sie neue Daten empfangen, ein Ergebnis aufzubauen.
Deshalb sind sie bei Berechnungen essentiell, bei denen nicht nur das Endergebnis wichtig ist, sondern auch die Schritte, die dazu geführt haben \cite[vgl.][S.~2]{reactive_programming1}.


\section{Futures und Promises} % (fold)
\label{sec:futures_und_promises}

Futures und Promises mit den Quellen \citealt{haller2013} und \citealt{typesafe2013}.

% section futures_und_promises (end)


\section{Streams} % (fold)
\label{sec:streams}

Streams sind inkrementelle Datenströme, die nicht-blockierendes Lesen erlauben und kombiniert und transformiert werden können.
Streams eignen sich, IO-Operationen performant und in funktionalem Stil durchzuführen.
Anwendungsbeispiele für Streams sind beispielsweise die Implementierung von Web-Servern oder Datenkompression.
Die in diesem Kapitel vorgestellten Streams entstanden im Umfeld der Programmiersprache Haskell und wurden von Oleg Kiselyov  vorgestellt \cite[vgl.][S.~19]{monad_reader}.


\subsection{Streams nach Kiselyov} % (fold)
\label{sub:streams_nach_kiselyov}

Weil die Iteratee IO-Streams durch Oleg Kiselyov begründet wurden, werden in diesem Abschnitt die Hintergründe dieser Streams nach Kiselyov vorgestellt.
Als Quellen hierfür dienen \citealt{kiselyov2012}, \citealt{iteratee_io} und \citealt{monad_reader}.


\subsubsection{Motivation} % (fold)
\label{ssub:motivation}

Motivation für die Entwicklung der Iteratee basierten Streams war der Wunsch nach inkrementeller, deklarativer Datenverarbeitung mit voller Kontrolle über den Ressourcenverbrauch.
Die einzelnen Komponenten der zu entwickelnden Bibliothek sollten möglichst leicht zu mächtigeren Komponenten kombinierbar sein.

% subsubsection motivation (end)


\subsubsection{Design} % (fold)
\label{ssub:design}

Iteratee IO-Streams bestehen aus vier Komponenten.
\lstinline|Stream|, \lstinline|Iteratee|, \lstinline|Enumerator| und \lstinline|Enumeratee|.
\lstinline|Stream| beinhaltet die gestreamten Elemente.
\lstinline|Iteratee| konsumiert \lstinline|Stream|-Elemente und dient somit als Datensenke.
\lstinline|Enumerator| generiert \lstinline|Stream|-Elemente und dient somit als Datenquelle.
Und \lstinline|Enumeratee| transformiert einen \lstinline|Enumerator|.
\lstinline|Enumeratee| ist also sowohl in der Rolle eines \lstinline|Iteratee|s, der die zu transformierenden Elemente konsumiert, als auch in der Rolle eines \lstinline|Enumerators|, der die transformierten Elemente bereitstellt.


\paragraph{Streams} % (fold)
\label{par:streams}\mbox{} % force new line

Die von der Datenquelle generierten Elemente werden in \lstinline|Stream|s verpackt.
Der Datentyp \lstinline|Stream| ist definiert als
\begin{lstlisting}[language=Haskell]
data Stream el = EOF (Maybe ErrMsg) | Chunk [el]
\end{lstlisting}

Der Typkonstruktor ist parametrisiert über den Typ der gehaltenen Elemente \lstinline|el|.

Für den Fall, dass die Datenquelle nicht erschöpft ist, existiert der Datenkonstruktor \lstinline|Chunk el|.
Dieser hält eine, möglicherweise leere, Liste von Elementen aus der Datenquelle.
Elemente werden nicht einzeln aus der Datenquelle empfangen, sondern in beliebig großen Mengen.

Für den Fall, dass die Datenquelle erschöpft, oder ein Fehler aufgetreten ist, existiert der Datenkonstruktor \lstinline|EOF|.
Wenn diesem Datenkonstruktor keine Fehlernachricht übergeben wird, bedeutet das, dass die Datenquelle ohne jede Fehler erschöpft ist.

Ein Wert vom Typ \lstinline|Stream| hat also drei mögliche Zustände:
\begin{enumerate}
  \item Es gibt neue Elemente (\lstinline|Chunk|).
  \item Die Datenquelle ist erschöpft (\lstinline|EOF| ohne Fehlernachricht).
  \item Es ist ein Fehler aufgetreten und es können keine neuen Elemente erzeugt werden (\lstinline|EOF| mit Fehlernachricht).
\end{enumerate}

% paragraph streams (end)


\paragraph{Iteratees} % (fold)
\label{par:iteratees}\mbox{} % force new line

Die von der Datenquelle in \lstinline|Stream|s verpackten Elemente werden von \lstinline|Iteratee|s konsumiert, um daraus ein Ergebnis aufzubauen.
Der Datentyp \lstinline|Iteratee| ist definiert als
\begin{lstlisting}[language=Haskell]
data Iteratee el m a =
    IE_done a
  | IE_cont (Maybe ErrMsg)
            (Stream el -> m (Iteratee el m a, Stream el))
\end{lstlisting}

Der Typkonstruktor ist über die drei Typen \lstinline|el|, \lstinline|m| und \lstinline|a| parametrisiert.
\lstinline|el| ist der Typ der zu konsumierenden Elemente.
\lstinline|m| ist die Monade, in dessen Kontext der \lstinline|Iteratee| agiert.
Und \lstinline|a| ist der Typ des zu berechnenden Ergebnisses.

Die Monade ist typischerweise \lstinline|IO|, damit der \lstinline|Iteratee| Seiteneffekte ausführen kann.
Das ist z.~B. notwendig, um in eine Datei zu schreiben, oder Daten über das Netzwerk zu verschicken.
In Haskell sind Seiteneffekte außerhalb der \lstinline|IO|-Monade nicht zulässig \cite[vgl.][]{haskell_io}.

Ein \lstinline|Iteratee|, der mit seiner Berechnung fertig ist, wird mit dem Datenkonstruktor \lstinline[breaklines=true]|IE_done a| erstellt.
Ein solcher \lstinline|Iteratee| hält nur sein berechnetes Ergebnis und nimmt keine weiteren Elemente an.

Um einen \lstinline|Iteratee| zu erstellen, der noch kein Endergebnis berechnet hat, wird der Datenkonstruktor \lstinline|IE_cont| verwendet.
Im Falle eines Fehlers wird als erstes Argument eine Fehlernachricht an den Datenkonstruktor übergeben.
Falls kein Fehler aufgetreten ist, wird als erstes Argument keine Fehlernachricht (\lstinline|Nothing|) übergeben.

Das zweite Argument für \lstinline|IE_cont| ist die Schritt-Funktion \lstinline[breaklines=true]|Stream el -> m (Iteratee el m a, Stream el)|.
Die Eingabe der Schritt-Funktion ist ein \lstinline|Stream| mit neuen zu verarbeitenden Elementen.
Die Ausgabe der Schritt-Funktion ist ein Paar.
Das erste Element des Ergebnispaars ist ein neuer \lstinline|Iteratee|, der den neuen Berechnungsstand nach dem Verarbeiten des Eingabe-\lstinline|Stream|s hält.
Das zweite Element des Ergebnispaars ist der Rest des Eingabe-\lstinline|Stream|s, der nicht konsumiert wurde.
Die Eingabe wird nicht vollständig konsumiert, wenn bei der Verarbeitung ein Fehler auftritt, oder wenn das Endergebnis auch ohne Konsum der gesamten Eingabe berechnet werden kann.
Ein Beispiel dafür ist die Suche nach einem bestimmten Element: Sobald das gesuchte Element gefunden wurde, müssen alle weiteren Elemente nicht mehr betrachtet werden.

Der Grund dafür, dass auch im Fehlerfall eine Schritt-Funktion übergeben wird, ist der, dass es dadurch für das System möglich ist, sich von Fehlern zu erholen.
Beispielsweise kann ein \lstinline|Iteratee| nach dem Empfang eines \lstinline|EOF Nothing|-Elements signalisieren, dass es noch mehr Daten benötigt.
In diesem Fall kann das System versuchen doch noch mehr Daten zu finden, sodass der \lstinline|Iteratee| erfolgreich zu einem Ergebnis kommen kann.

Ein Wert vom Typ \lstinline|Iteratee| hat also auch wieder drei mögliche Zustände:
\begin{enumerate}
  \item Es wurde erfolgreich ein Ergebnis berechnet (\lstinline|IE_Done|).
  \item Es werden weitere Daten zur Berechnung benötigt (\lstinline|IE_cont| ohne Fehlernachricht).
  \item Es ist ein Fehler aufgetreten, von dem sich das System aber wieder erholen kann (\lstinline|IE_cont| mit Fehlernachricht).
\end{enumerate}

% paragraph iteratees (end)


\paragraph{Enumerators} % (fold)
\label{par:enumerators}\mbox{} % force new line

Ein \lstinline|Enumerator| ist die Datenquelle, die ihre Daten, in \lstinline|Stream|s verpackt, bereitstellt.
Der Datentyp \lstinline|Enumerator| ist definiert als
\begin{lstlisting}[language=Haskell]
type Enumerator el m a = Iteratee el m a -> m (Iteratee el m a)
\end{lstlisting}

Ein \lstinline|Enumerator| ist eine Funktion von \lstinline|Iteratee| nach \lstinline|Iteratee| und ist über die Typen des übergebenen \lstinline|Iteratee|s parametrisiert.
Der Eingabewert ist der \lstinline|Iteratee|, an den die generierten Elemente gesendet werden.
Der Rückgabewert ist der übergebene \lstinline|Iteratee| nach Fertigstellung oder Abbruch seiner Berechnung.
Der zurückgegebene \lstinline|Iteratee| befindet sich in der Monade \lstinline|m|.
Diese Monade gilt sowohl für den \lstinline|Iteratee|, als auch für den \lstinline|Enumerator|.
Dadurch ist es für Werte beider Typen möglich, bei passender Monade, Seiteneffekte zu verursachen.
Es ist zwar denkbar und durch Anpassung des \lstinline|Enumerator|-Typs auch umsetzbar, dass \lstinline|Enumerator| und \lstinline|Iteratee| in unterschiedlichen Monaden ausgeführt werden, doch wird diese Funktionalität in aller Regel nicht benötigt.

Bei der Anwendung dieser Funktion werden dem \lstinline|Iteratee| so lange Daten übergeben, bis die Datenquelle erschöpft ist, oder bis der \lstinline|Iteratee| keine Daten mehr annimmt.
Die Herkunft der Daten, die der \lstinline|Enumerator| an den \lstinline|Iteratee| sendet, ist durch die Monade \lstinline|m| bestimmt.
Weil Seiteneffekte nur in der \lstinline|IO|-Monade möglich sind, ist \lstinline|m| typischerweise \lstinline|IO|.
Dadurch ist es beispielsweise möglich, die Daten aus Dateien oder dem Netzwerk zu empfangen.

% paragraph enumerators (end)


% subsubsection design (end)


% subsection streams_nach_kiselyov (end)


\subsection{Streams in Play} % (fold)
\label{sub:streams_in_play}


\subsubsection{Überblick} % (fold)
\label{sssec:streams_ueberblick}

Das Stream Paket \lstinline|play.api.libs.iteratee| beinhaltet die drei wesentlichen Bestandteile der Stream-API.
Diese sind \lstinline|Iteratee|, \lstinline|Enumerator| und \lstinline|Enumeratee|.
Ein Iteratee ist die Datensenke, die Daten eines Enumerators, der Datenquelle, konsumiert.
Enumeratees sind dazu da, Datenströme zu transformieren, sind also Zwischenhändler zwischen Iteratees und Enumerators.

% subsubsection streams_ueberblick


\subsubsection{Iteratees} % (fold)
\label{sssec:iteratees}

Iteratees nehmen Elemente kontinuierlich Elemente auf und berechnen daraus ein Ergebnis.
Statt eines Ergebnisses können auch Seiteneffekte ausgeführt werden.
Ein einfacher Iteratee ist beispielsweise ein Iteratee, der jedes Element, das er empfängt, auf der Kommandozeile ausgibt.
\begin{lstlisting}
val loggerIteratee: Iteratee[String, Unit] =
  Iteratee.foreach(println)
\end{lstlisting}
Um den Iteratee auszuführen benötigen wir einen Enumerator, der Daten an den Iteratee sendet.
\begin{lstlisting}
val namesEnumerator: Enumerator[String] =
  Enumerator("Foo", "Bar", "Baz")
\end{lstlisting}
Und schließlich müssen diese Daten an den Iteratee gesendet werden.
\begin{lstlisting}
val appliedLoggerIteratee: Future[Iteratee[String, Unit]] =
  namesEnumerator(loggerIteratee)
\end{lstlisting}

% subsubsection iteratees


\subsubsection{Regeln} % (fold)
\label{ssub:regeln}

Die folgenden Regeln sind \citealt{kiselyov2012}~(S.~12--13) entnommen und dienen derzeit nur zum Verständnis des Autors.
Sie werden später, sofern möglich, an geeigneter Stelle einsortiert.

\lstinline!k |> l! ist der Alternativ-Kombinator. Der Iteratee, der als erstes ein Ergebnis liefert, wird zurückgegeben.

\begin{enumerate}
  \item Komposition
    \begin{lstlisting}
enstr (s1 ++ s2) = enstr s2 . enstr s1
    \end{lstlisting}

    Eingaben konkatenieren ist das gleiche, wie Enumeratoren zu konkatenieren.

  \item Verkettung
    \begin{lstlisting}
enstr (s1 ++ s2)(i >>= f) = enstr s1 i >>= enstr s2 . f
    \end{lstlisting}

    Wenn Iteratee i s1 erkennt, dann ist das Verarbeiten und Verwerten der der konkatenierten Eingaben das gleiche, wie das Verarbeiten und Verwerten der ersten Eingabe und anschließend das Verarbeiten der zweiten Eingabe.

  \item Neutrales Element
    \begin{lstlisting}
failure >>= f = failure
    \end{lstlisting}

    Wenn ein Iteratee einen Fehler erzeugt, haben auch folgende Iteratees keine Chance mehr auf Erfolg.

  \item Rechtsdistributivität
    \begin{lstlisting}
i >>= \x -> (k1 x |> k2 x) = (i >>= k1) |> (i >>= k2)
    \end{lstlisting}

    Iteratees sind rechtsdistributiv, d.h. erst Iteratee i auszuführen und auf das Ergebnis k1 oder k2 auszuführen ist das gleiche, als i und darauf k1 auszuführen oder i und darauf k2 auszuführen.
\end{enumerate}

% subsubsection regeln (end)

% subsection streams_in_play (end)


% section streams (end)


% section serverseitig (end)

% chapter reaktive_programmierung (end)




\chapter{Schluss} % (fold)
\label{cha:schluss}

% chapter schluss (end)


%%%%

%% appendix if used
%%\appendix
%%\typeout{===== File: appendix}
%%\include{appendix}

% bibliography and other stuff
\backmatter

\typeout{===== Section: literature}
%% read the documentation for customizing the style
\bibliographystyle{dinat}
\bibliography{thesis}

\typeout{===== Section: nomenclature}
%% uncomment if a TOC entry is needed
%%\addcontentsline{toc}{chapter}{Glossar}
\renewcommand{\nomname}{Glossar}
\clearpage
\markboth{\nomname}{\nomname} %% see nomencl doc, page 9, section 4.1
\printnomenclature

%% index
\typeout{===== Section: index}
\printindex

\HAWasurency

\end{document}
